/**
 * name: @tresjs/core
 * version: v4.2.7
 * (c) 2024
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var bt = Object.defineProperty;
var Pt = (e, t, n) => t in e ? bt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var me = (e, t, n) => Pt(e, typeof t != "symbol" ? t + "" : t, n);
import { ref as H, computed as V, watchEffect as Te, onUnmounted as K, shallowRef as $, watch as ce, readonly as ye, unref as J, provide as _e, inject as Ct, isRef as Mt, reactive as Et, defineComponent as Be, useSlots as Tt, getCurrentInstance as Ie, onMounted as St, openBlock as At, createElementBlock as xt, normalizeClass as kt, normalizeStyle as Lt, createRenderer as Rt, h as He, Fragment as Ot } from "vue";
import * as et from "three";
import { PerspectiveCamera as we, Camera as Dt, Clock as tt, Vector3 as Se, Color as Z, Scene as nt, MathUtils as rt, MeshBasicMaterial as ot, DoubleSide as jt, REVISION as Bt, SRGBColorSpace as It, ACESFilmicToneMapping as st, PCFSoftShadowMap as Ht, NoToneMapping as $t, WebGLRenderer as he, TextureLoader as Ut, Vector2 as ge, Raycaster as Ft, BufferAttribute as Wt, Object3D as Nt, Line as zt, BufferGeometry as $e, Float32BufferAttribute as Ue, LineBasicMaterial as Gt, Mesh as Vt, BackSide as Yt, DirectionalLightHelper as qt, PointLightHelper as Jt, SpotLightHelper as Kt, HemisphereLightHelper as Qt, ArrowHelper as Xt } from "three";
import { createEventHook as j, useRafFn as it, toValue as k, unrefElement as Zt, useDevicePixelRatio as en, usePointer as tn, useElementBounding as nn, useWindowSize as rn, useElementSize as on, refDebounced as Fe, tryOnScopeDispose as sn, useFps as an, useMemory as ln } from "@vueuse/core";
const cn = "@tresjs/core", un = "module", fn = "4.2.7", dn = "pnpm@9.1.4", pn = "Declarative ThreeJS using Vue Components", mn = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", hn = "MIT", gn = {
  type: "git",
  url: "git+https://github.com/Tresjs/tres.git"
}, vn = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
], yn = !1, _n = {
  ".": {
    types: "./dist/index.d.ts",
    import: "./dist/tres.js",
    require: "./dist/tres.umd.cjs"
  },
  "./components": {
    types: "./dist/src/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/src/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/src/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/src/utils/index.d.ts"
  },
  "./*": "./*"
}, wn = "./dist/tres.js", bn = "./dist/tres.js", Pn = "./dist/index.d.ts", Cn = [
  "*.d.ts",
  "dist"
], Mn = {
  access: "public"
}, En = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui --coverage.enabled=true",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint .",
  "lint:fix": "eslint . --fix",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts",
  prepare: "node .husky/install.mjs"
}, Tn = {
  three: ">=0.133",
  vue: ">=3.4"
}, Sn = {
  "@alvarosabu/utils": "^3.2.0",
  "@vue/devtools-api": "^6.6.3",
  "@vueuse/core": "^10.11.0"
}, An = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.11.0",
  "@tresjs/cientos": "3.9.0",
  "@tresjs/eslint-config": "^1.1.0",
  "@types/three": "^0.166.0",
  "@typescript-eslint/eslint-plugin": "^7.16.0",
  "@typescript-eslint/parser": "^7.16.0",
  "@vitejs/plugin-vue": "^5.0.5",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/coverage-v8": "^2.0.2",
  "@vitest/ui": "^2.0.2",
  "@vue/test-utils": "^2.4.6",
  eslint: "^9.6.0",
  "eslint-plugin-vue": "^9.27.0",
  esno: "^4.7.0",
  gsap: "^3.12.5",
  husky: "^9.0.11",
  jsdom: "^24.1.0",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.2",
  "release-it": "^17.5.0",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.12.0",
  sponsorkit: "^0.14.6",
  three: "^0.166.1",
  unocss: "^0.61.3",
  unplugin: "^1.11.0",
  "unplugin-vue-components": "^0.27.2",
  vite: "^5.3.3",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.9.1",
  "vite-plugin-inspect": "^0.8.4",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.3.0",
  vitest: "^2.0.2",
  vue: "^3.4.31",
  "vue-demi": "^0.14.8"
}, xn = {
  name: cn,
  type: un,
  version: fn,
  packageManager: dn,
  description: pn,
  author: mn,
  license: hn,
  repository: gn,
  keywords: vn,
  sideEffects: yn,
  exports: _n,
  main: wn,
  module: bn,
  types: Pn,
  files: Cn,
  publishConfig: Mn,
  scripts: En,
  peerDependencies: Tn,
  dependencies: Sn,
  devDependencies: An
};
function be(e) {
  return typeof e > "u";
}
function de(e) {
  return Array.isArray(e);
}
function kn(e) {
  return typeof e == "number";
}
function at(e) {
  return typeof e == "string";
}
function G(e) {
  return typeof e == "function";
}
function U(e) {
  return e === Object(e) && !de(e) && !G(e);
}
function N(e) {
  return U(e) && "isObject3D" in e && !!e.isObject3D;
}
function We(e) {
  return U(e) && "isCamera" in e && !!e.isCamera;
}
function Ln(e) {
  return U(e) && "isBufferGeometry" in e && !!e.isBufferGeometry;
}
function Rn(e) {
  return U(e) && "isMaterial" in e && !!e.isMaterial;
}
function On(e) {
  return U(e) && "isLight" in e && !!e.isLight;
}
function Dn(e) {
  return U(e) && "isFog" in e && !!e.isFog;
}
function jn(e) {
  return U(e) && "isScene" in e && !!e.isScene;
}
function oe(e) {
  return N(e) || Ln(e) || Rn(e) || Dn(e);
}
function Bn(e) {
  return U(e) && !!e.isPrimitive;
}
const In = ({ sizes: e }) => {
  const t = H([]), n = V(
    () => t.value[0]
  ), r = (i) => {
    const a = i instanceof Dt ? i : t.value.find((o) => o.uuid === i);
    if (!a)
      return;
    const c = t.value.filter(({ uuid: o }) => o !== a.uuid);
    t.value = [a, ...c];
  }, s = (i, a = !1) => {
    if (We(i)) {
      const c = i;
      if (t.value.some(({ uuid: o }) => o === c.uuid))
        return;
      a ? r(c) : t.value.push(c);
    }
  }, l = (i) => {
    if (We(i)) {
      const a = i;
      t.value = t.value.filter(({ uuid: c }) => c !== a.uuid);
    }
  };
  return Te(() => {
    e.aspectRatio.value && t.value.forEach((i) => {
      !i.manual && (i instanceof we || Hn(i)) && (i instanceof we ? i.aspect = e.aspectRatio.value : (i.left = e.width.value * -0.5, i.right = e.width.value * 0.5, i.top = e.height.value * 0.5, i.bottom = e.height.value * -0.5), i.updateProjectionMatrix());
    });
  }), K(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    registerCamera: s,
    deregisterCamera: l,
    setCameraActive: r
  };
};
function Hn(e) {
  return e.hasOwnProperty("isOrthographicCamera") && e.isOrthographicCamera;
}
const lt = j(), ct = j(), Ae = j(), ee = new tt();
let ue = 0, fe = 0;
const { pause: $n, resume: Ne, isActive: Un } = it(
  () => {
    lt.trigger({ delta: ue, elapsed: fe, clock: ee }), ct.trigger({ delta: ue, elapsed: fe, clock: ee }), Ae.trigger({ delta: ue, elapsed: fe, clock: ee });
  },
  { immediate: !1 }
);
Ae.on(() => {
  ue = ee.getDelta(), fe = ee.getElapsedTime();
});
let ze = !1;
const Fr = () => (ze || (ze = !0, Ne()), {
  onBeforeLoop: lt.on,
  onLoop: ct.on,
  onAfterLoop: Ae.on,
  pause: $n,
  resume: Ne,
  isActive: Un
}), Wr = !0, se = "[TresJS ▲ ■ ●] ";
function Y() {
  function e(...r) {
    typeof r[0] == "string" ? r[0] = se + r[0] : r.unshift(se), console.error(...r);
  }
  function t(...r) {
    typeof r[0] == "string" ? r[0] = se + r[0] : r.unshift(se), console.warn(...r);
  }
  function n(r, s) {
  }
  return {
    logError: e,
    logWarning: t,
    logMessage: n
  };
}
function Nr(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Se ? [e.x, e.y, e.z] : e;
}
function Fn(e) {
  return e instanceof Z ? e : Array.isArray(e) ? new Z(...e) : new Z(e);
}
class Wn extends et.Mesh {
  constructor(...n) {
    super(...n);
    me(this, "type", "HightlightMesh");
    me(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const r = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * r);
    this.scale.set(i, i, i);
  }
}
const ut = (e, t) => {
  for (const n of Object.keys(t))
    t[n] instanceof Object && Object.assign(t[n], ut(e[n], t[n]));
  return Object.assign(e || {}, t), e;
}, Nn = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", zn = /* @__PURE__ */ Yn(Nn);
function Ge(e) {
  return e && e.nodeType === 1;
}
function ie(e) {
  return e.replace(/-([a-z])/g, (t, n) => n.toUpperCase());
}
const Gn = /\B([A-Z])/g;
function Vn(e) {
  return e.replace(Gn, "-$1").toLowerCase();
}
function Yn(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let s = 0; s < r.length; s++)
    n[r[s]] = !0;
  return (s) => !!n[s];
}
const Ve = (e, t) => {
  if (!t)
    return;
  const n = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
  return n == null ? void 0 : n.reduce((r, s) => r && r[s], e);
}, qn = (e, t, n) => {
  const r = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
  r && r.reduce((s, l, i) => (s[l] === void 0 && (s[l] = {}), i === r.length - 1 && (s[l] = n), s[l]), e);
};
function ft(e, t) {
  if (Ge(e) && Ge(t)) {
    const s = e.attributes, l = t.attributes;
    return s.length !== l.length ? !1 : Array.from(s).every(({ name: i, value: a }) => t.getAttribute(i) === a);
  }
  if (e === t)
    return !0;
  if (e === null || typeof e != "object" || t === null || typeof t != "object")
    return !1;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (const s of n)
    if (!r.includes(s) || !ft(e[s], t[s]))
      return !1;
  return !0;
}
function Jn(e, t) {
  if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!ft(e[n], t[n]))
      return !1;
  return !0;
}
const Kn = Array.isArray;
function Qn(e, t, n, r) {
  const s = (c) => {
    if (c.uuid === t)
      return c;
    for (const o of c.children) {
      const u = s(o);
      if (u)
        return u;
    }
  }, l = s(e);
  if (!l) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let i = l;
  for (let c = 0; c < n.length - 1; c++)
    if (i[n[c]] !== void 0)
      i = i[n[c]];
    else {
      console.warn(`Property path is not valid: ${n.join(".")}`);
      return;
    }
  const a = n[n.length - 1];
  i[a] !== void 0 ? i[a] = r : console.warn(`Property path is not valid: ${n.join(".")}`);
}
function Xn(e) {
  const t = new ot({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: !0,
    opacity: 0.2,
    depthTest: !1,
    // So the highlight is always visible
    side: jt
    // To e
  });
  return new Wn(e.geometry.clone(), t);
}
function Zn(e) {
  var n;
  let t = e.value;
  return e.value && ((n = e.value) != null && n.isMesh) && (t = e.value.position), Array.isArray(e.value) && (t = new Se(...t)), t;
}
function er(e) {
  return "map" in e;
}
function Ye(e) {
  er(e) && e.map && e.map.dispose(), e.dispose();
}
function dt(e) {
  var n, r;
  if (e.parent && ((n = e.removeFromParent) == null || n.call(e)), delete e.__tres, [...e.children].forEach((s) => dt(s)), !(e instanceof nt)) {
    const s = e;
    e && ((r = e.dispose) == null || r.call(e)), s.geometry && (s.geometry.dispose(), delete s.geometry), Array.isArray(s.material) ? (s.material.forEach((l) => Ye(l)), delete s.material) : s.material && (Ye(s.material), delete s.material);
  }
}
function tr(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    t(e[r], r) && (e[n] = e[r], n++);
  return e.length = n, e;
}
function Pe(e, t) {
  let n = e;
  if (t.includes("-")) {
    const r = t.split("-");
    let s = r.shift();
    for (; n && r.length; )
      s in n ? (n = n[s], s = r.shift()) : s = qe(s, r.shift());
    return { target: n, key: qe(s, ...r) };
  } else
    return { target: n, key: t };
}
function qe(...e) {
  return e.map((t, n) => n === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join("");
}
const Je = /-\d+$/;
function nr(e, t, n) {
  if (at(n)) {
    if (Je.test(n)) {
      const l = n.replace(Je, ""), { target: i, key: a } = Pe(e, l);
      if (!Array.isArray(i[a])) {
        const c = i[a], o = [];
        o.__tresDetach = () => {
          o.every((u) => be(u)) && (i[a] = c);
        }, i[a] = o;
      }
    }
    const { target: r, key: s } = Pe(e, n);
    t.__tres.previousAttach = r[s], r[s] = Q(t);
  } else
    t.__tres.previousAttach = n(e, t);
}
function rr(e, t, n) {
  var r, s, l;
  if (at(n)) {
    const { target: i, key: a } = Pe(e, n), c = t.__tres.previousAttach;
    c === void 0 ? delete i[a] : i[a] = c, "__tresDetach" in i && i.__tresDetach();
  } else
    (s = (r = t.__tres) == null ? void 0 : r.previousAttach) == null || s.call(r, e, t);
  (l = t.__tres) == null || delete l.previousAttach;
}
function z(e, t, n) {
  const r = e;
  return r.__tres = {
    type: "unknown",
    eventCount: 0,
    root: n,
    handlers: {},
    memoizedProps: {},
    objects: [],
    parent: null,
    previousAttach: null,
    ...t
  }, r.__tres.attach || (r.isMaterial ? r.__tres.attach = "material" : r.isBufferGeometry ? r.__tres.attach = "geometry" : r.isFog && (r.__tres.attach = "fog")), r;
}
function pt(e) {
  var n;
  const t = (n = e == null ? void 0 : e.__tres) == null ? void 0 : n.root;
  t && t.render && t.render.canBeInvalidated.value && t.invalidate();
}
function or(e, t, n) {
  var s;
  if (!G(e.setPixelRatio))
    return;
  let r = 0;
  if (de(n) && n.length >= 2) {
    const [l, i] = n;
    r = rt.clamp(t, l, i);
  } else kn(n) ? r = n : r = t;
  r !== ((s = e.getPixelRatio) == null ? void 0 : s.call(e)) && e.setPixelRatio(r);
}
function sr(e, t, n, r, s) {
  const l = [...t.__tres.objects], i = Q(t);
  if (e = Q(e), i === e)
    return !0;
  const a = z(e, t.__tres ?? {}, s), c = t.parent ?? t.__tres.parent ?? null, o = { ...t.__tres.memoizedProps };
  delete o.object;
  for (const u of l)
    mt(u, s), ht(u, s);
  i.__tres.objects = [], r.remove(t);
  for (const [u, v] of Object.entries(o))
    r.patchProp(a, u, a[u], v);
  n(e), r.insert(t, c);
  for (const u of l)
    r.insert(u, t);
  return !0;
}
function Q(e) {
  return Bn(e) ? (e.object.__tres = e.__tres, e.object) : e;
}
function mt(e, t) {
  var r, s, l, i;
  const n = ((r = e.__tres) == null ? void 0 : r.parent) || t.scene.value;
  e.__tres && (e.__tres.parent = null), n && n.__tres && "objects" in n.__tres && tr(n.__tres.objects, (a) => a !== e), (s = e.__tres) != null && s.attach ? rr(n, e, e.__tres.attach) : ((i = (l = e.parent) == null ? void 0 : l.remove) == null || i.call(l, Q(e)), e.parent = null);
}
function ht(e, t) {
  var n;
  (n = e.traverse) == null || n.call(e, (r) => {
    var s;
    t.deregisterCamera(r), (s = t.eventManager) == null || s.deregisterPointerMissedObject(r);
  }), t.deregisterCamera(e), pt(e);
}
const ir = Number.parseInt(Bt.replace("dev", "")), ae = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: It,
    toneMapping: st,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Ht
    }
  },
  flat: {
    toneMapping: $t,
    toneMappingExposure: 1
  }
};
function ar({
  canvas: e,
  options: t,
  contextParts: { sizes: n, render: r, invalidate: s, advance: l }
}) {
  const i = V(() => ({
    alpha: k(t.alpha) ?? !0,
    depth: k(t.depth),
    canvas: Zt(e),
    context: k(t.context),
    stencil: k(t.stencil),
    antialias: k(t.antialias) ?? !0,
    precision: k(t.precision),
    powerPreference: k(t.powerPreference),
    premultipliedAlpha: k(t.premultipliedAlpha),
    preserveDrawingBuffer: k(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: k(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: k(t.failIfMajorPerformanceCaveat)
  })), a = $(new he(i.value));
  function c() {
    t.renderMode === "on-demand" && s();
  }
  ce(i, () => {
    a.value.dispose(), a.value = new he(i.value), c();
  }), ce([n.width, n.height], () => {
    a.value.setSize(n.width.value, n.height.value), c();
  }, {
    immediate: !0
  }), ce(() => t.clearColor, c);
  const { pixelRatio: o } = en(), { logError: u } = Y(), f = (() => {
    const g = new he(), b = {
      shadowMap: {
        enabled: g.shadowMap.enabled,
        type: g.shadowMap.type
      },
      toneMapping: g.toneMapping,
      toneMappingExposure: g.toneMappingExposure,
      outputColorSpace: g.outputColorSpace
    };
    return g.dispose(), b;
  })(), h = k(t.renderMode);
  return h === "on-demand" && s(), h === "manual" && setTimeout(() => {
    l();
  }, 100), Te(() => {
    const g = k(t.preset);
    g && (g in ae || u(`Renderer Preset must be one of these: ${Object.keys(ae).join(", ")}`), ut(a.value, ae[g])), or(a.value, o.value, k(t.dpr)), h === "always" && (r.frames.value = Math.max(1, r.frames.value));
    const b = (C, M) => {
      const P = k(C), E = () => {
        if (g)
          return Ve(ae[g], M);
      };
      if (P !== void 0)
        return P;
      const S = E();
      return S !== void 0 ? S : Ve(f, M);
    }, y = (C, M) => qn(a.value, M, b(C, M));
    y(t.shadows, "shadowMap.enabled"), y(t.toneMapping ?? st, "toneMapping"), y(t.shadowMapType, "shadowMap.type"), ir < 150 && y(!t.useLegacyLights, "physicallyCorrectLights"), y(t.outputColorSpace, "outputColorSpace"), y(t.toneMappingExposure, "toneMappingExposure");
    const d = b(t.clearColor, "clearColor");
    d && a.value.setClearColor(
      d ? Fn(d) : new Z(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  }), K(() => {
    a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
const lr = (e) => !!e && e.constructor === Array;
function cr(e) {
  const t = { nodes: {}, materials: {} };
  return e && e.traverse((n) => {
    n.name && (t.nodes[n.name] = n), n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material);
  }), t;
}
async function zr(e, t, n, r, s) {
  const { logError: l } = Y(), i = new e();
  s && s(i), n && n(i);
  const c = (Array.isArray(t) ? t : [t]).map(
    (o) => new Promise((u, v) => {
      i.load(
        o,
        (f) => {
          const h = f;
          h.scene && Object.assign(h, cr(h.scene)), u(h);
        },
        r,
        (f) => v(l("[useLoader] - Failed to load resource", f))
      );
    })
  );
  return lr(t) ? await Promise.all(c) : await c[0];
}
async function Gr(e, t) {
  const n = new Ut(t), r = (s) => new Promise((l, i) => {
    n.load(
      s,
      (a) => l(a),
      () => null,
      () => {
        i(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Kn(e)) {
    const s = await Promise.all(e.map((l) => r(l)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: l,
      normalMap: i,
      roughnessMap: a,
      metalnessMap: c,
      aoMap: o,
      alphaMap: u,
      matcap: v
    } = e;
    return {
      map: s ? await r(s) : null,
      displacementMap: l ? await r(l) : null,
      normalMap: i ? await r(i) : null,
      roughnessMap: a ? await r(a) : null,
      metalnessMap: c ? await r(c) : null,
      aoMap: o ? await r(o) : null,
      alphaMap: u ? await r(u) : null,
      matcap: v ? await r(v) : null
    };
  }
}
const ur = (e, t) => {
  const n = V(() => t.renderer.value.domElement), r = $([]), { x: s, y: l } = tn({ target: n });
  let i = 0;
  const { width: a, height: c, top: o, left: u } = nn(n), v = ({ x: m, y: T }) => {
    if (n.value)
      return {
        x: (m - u.value) / a.value * 2 - 1,
        y: -((T - o.value) / c.value) * 2 + 1
      };
  }, f = ({ x: m, y: T }) => {
    if (t.camera.value)
      return t.raycaster.value.setFromCamera(new ge(m, T), t.camera.value), r.value = t.raycaster.value.intersectObjects(e.value, !0), r.value;
  }, h = (m) => {
    const T = v({
      x: (m == null ? void 0 : m.clientX) ?? s.value,
      y: (m == null ? void 0 : m.clientY) ?? l.value
    });
    return T ? f(T) || [] : [];
  }, g = j(), b = j(), y = j(), d = j(), C = j(), M = j(), P = j(), E = j();
  function S(m) {
    const T = {};
    for (const F in m)
      typeof F != "function" && (T[F] = m[F]);
    return T;
  }
  const _ = (m, T) => {
    var Oe, De, je;
    const F = S(T), re = new Se(T == null ? void 0 : T.clientX, T == null ? void 0 : T.clientY, 0).unproject((Oe = t.camera) == null ? void 0 : Oe.value);
    m.trigger({
      ...F,
      intersections: r.value,
      // The unprojectedPoint is wrong, math needs to be fixed
      unprojectedPoint: re,
      ray: (De = t.raycaster) == null ? void 0 : De.value.ray,
      camera: (je = t.camera) == null ? void 0 : je.value,
      sourceEvent: T,
      delta: i,
      stopPropagating: !1
    });
  };
  let A;
  const L = (m) => {
    h(m), _(y, m), A = m;
  }, p = () => {
    A && L(A);
  };
  let w, x, D;
  const O = (m) => {
    var T;
    w = (T = r.value[0]) == null ? void 0 : T.object, i = 0, x = new ge(
      (m == null ? void 0 : m.clientX) ?? s.value,
      (m == null ? void 0 : m.clientY) ?? l.value
    ), _(C, m);
  };
  let B, R = !1;
  const ne = (m) => {
    var T, F, re;
    m instanceof PointerEvent && (r.value.length === 0 && _(M, m), w === ((T = r.value[0]) == null ? void 0 : T.object) && (D = new ge(
      (m == null ? void 0 : m.clientX) ?? s.value,
      (m == null ? void 0 : m.clientY) ?? l.value
    ), i = x == null ? void 0 : x.distanceTo(D), m.button === 0 ? (_(g, m), B === ((F = r.value[0]) == null ? void 0 : F.object) ? R = !0 : (B = (re = r.value[0]) == null ? void 0 : re.object, R = !1)) : m.button === 2 && _(P, m)), _(d, m));
  }, ke = (m) => {
    R && (_(b, m), B = void 0, R = !1);
  }, Le = (m) => _(y, m), Re = (m) => _(E, m);
  return n.value.addEventListener("pointerup", ne), n.value.addEventListener("pointerdown", O), n.value.addEventListener("pointermove", L), n.value.addEventListener("pointerleave", Le), n.value.addEventListener("dblclick", ke), n.value.addEventListener("wheel", Re), K(() => {
    n != null && n.value && (n.value.removeEventListener("pointerup", ne), n.value.removeEventListener("pointerdown", O), n.value.removeEventListener("pointermove", L), n.value.removeEventListener("pointerleave", Le), n.value.removeEventListener("dblclick", ke), n.value.removeEventListener("wheel", Re));
  }), {
    intersects: r,
    onClick: (m) => g.on(m).off,
    onDblClick: (m) => b.on(m).off,
    onContextMenu: (m) => P.on(m).off,
    onPointerMove: (m) => y.on(m).off,
    onPointerUp: (m) => d.on(m).off,
    onPointerDown: (m) => C.on(m).off,
    onPointerMissed: (m) => M.on(m).off,
    onWheel: (m) => E.on(m).off,
    forceUpdate: p
  };
};
function Vr() {
  const { logWarning: e } = Y();
  function t(l, i, a) {
    let c = null;
    return l.traverse((o) => {
      o[i] === a && (c = o);
    }), c || e(`Child with ${i} '${a}' not found.`), c;
  }
  function n(l, i, a) {
    const c = [];
    return l.traverse((o) => {
      o[i].includes(a) && c.push(o);
    }), c.length || e(`Children with ${i} '${a}' not found.`), c;
  }
  function r(l, i) {
    return t(l, "name", i);
  }
  function s(l, i) {
    return n(l, "name", i);
  }
  return {
    seek: t,
    seekByName: r,
    seekAll: n,
    seekAllByName: s
  };
}
function xe(e) {
  let t = 0;
  return e.traverse((n) => {
    if (n.isMesh && n.geometry && n.type !== "HightlightMesh") {
      const r = n.geometry, s = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, l = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, i = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, c = s + l + i + a;
      t += c;
    }
  }), t;
}
function fr(e) {
  return (e / 1024).toFixed(2);
}
const Ce = H({}), Me = (e) => Object.assign(Ce.value, e);
function dr(e, t, n) {
  var L;
  const r = $(), s = $();
  e && (r.value = e), t && (s.value = t);
  const l = (p) => {
    var w;
    return ((w = p.__tres) == null ? void 0 : w.eventCount) > 0;
  }, i = (p) => {
    var w;
    return ((w = p.children) == null ? void 0 : w.some((x) => i(x))) || l(p);
  }, a = $(((L = r.value) == null ? void 0 : L.children).filter(i) || []);
  function c(p, w) {
    if (Array.isArray(p))
      for (const x of p)
        x(w);
    typeof p == "function" && p(w);
  }
  function o(p, w) {
    const x = [], D = () => w.stopPropagating = !0;
    w.stopPropagation = D;
    for (const O of w == null ? void 0 : w.intersections) {
      if (w.stopPropagating)
        return;
      w = { ...w, ...O };
      const { object: B } = O;
      w.eventObject = B, c(B[p], w), x.push(B);
      let R = B.parent;
      for (; R !== null && !w.stopPropagating && !x.includes(R); )
        w.eventObject = R, c(R[p], w), x.push(R), R = R.parent;
      const ne = Vn(p.slice(2));
      n(ne, { intersection: O, event: w });
    }
  }
  const {
    onClick: u,
    onDblClick: v,
    onContextMenu: f,
    onPointerMove: h,
    onPointerDown: g,
    onPointerUp: b,
    onPointerMissed: y,
    onWheel: d,
    forceUpdate: C
  } = ur(a, t);
  b((p) => o("onPointerUp", p)), g((p) => o("onPointerDown", p)), u((p) => o("onClick", p)), v((p) => o("onDoubleClick", p)), f((p) => o("onContextMenu", p)), d((p) => o("onWheel", p));
  let M = [];
  h((p) => {
    const w = p.intersections.map(({ object: D }) => D), x = p.intersections;
    M.forEach(({ object: D }) => {
      w.includes(D) || (p.intersections = M, o("onPointerLeave", p), o("onPointerOut", p));
    }), p.intersections = x, p.intersections.forEach(({ object: D }) => {
      M.includes(D) || (o("onPointerEnter", p), o("onPointerOver", p));
    }), o("onPointerMove", p), M = p.intersections;
  });
  const P = [];
  y((p) => {
    const w = () => p.stopPropagating = !0;
    p.stopPropagation = w, P.forEach((x) => {
      p.stopPropagating || (p.eventObject = x, c(x.onPointerMissed, p));
    }), n("pointer-missed", { event: p });
  });
  function E(p) {
    oe(p) && N(p) && a.value.push(p);
  }
  function S(p) {
    if (oe(p) && N(p)) {
      const w = a.value.indexOf(p);
      w > -1 && a.value.splice(w, 1);
    }
  }
  function _(p) {
    oe(p) && N(p) && p.onPointerMissed && P.push(p);
  }
  function A(p) {
    if (oe(p) && N(p)) {
      const w = P.indexOf(p);
      w > -1 && P.splice(w, 1);
    }
  }
  return t.eventManager = {
    forceUpdate: C,
    registerObject: E,
    deregisterObject: S,
    registerPointerMissedObject: _,
    deregisterPointerMissedObject: A
  }, {
    forceUpdate: C,
    registerObject: E,
    deregisterObject: S,
    registerPointerMissedObject: _,
    deregisterPointerMissedObject: A
  };
}
function pr(e, t, n = 10) {
  const r = k(e) ? rn() : on(V(() => k(t).parentElement)), s = ye(Fe(r.width, n)), l = ye(Fe(r.height, n)), i = V(() => s.value / l.value);
  return {
    height: l,
    width: s,
    aspectRatio: i
  };
}
function ve() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();
  let n = 0, r = !1;
  const s = () => {
    const o = Array.from(e.entries()).sort((u, v) => {
      const f = u[1].priority - v[1].priority;
      return f === 0 ? u[1].addI - v[1].addI : f;
    });
    t.clear(), o.forEach((u) => t.add(u[0]));
  }, l = (o) => {
    e.delete(o), t.delete(o);
  };
  return { on: (o, u = 0) => {
    e.set(o, { priority: u, addI: n++ });
    const v = () => l(o);
    return sn(v), r = !0, {
      off: v
    };
  }, off: l, trigger: (...o) => {
    r && (s(), r = !1), t.forEach((u) => u(...o));
  }, dispose: () => {
    e.clear(), t.clear();
  }, get count() {
    return e.size;
  } };
}
function mr() {
  let e = !0, t = !0, n = !1;
  const r = new tt(!1), s = H(r.running), l = H(!1);
  let i;
  const a = rt.generateUUID();
  let c = null;
  const o = ve(), u = ve(), v = ve();
  S();
  let f = {};
  function h(_) {
    f = _;
  }
  function g(_, A, L = 0) {
    switch (A) {
      case "before":
        return o.on(_, L);
      case "render":
        return c || (c = _), u.dispose(), u.on(_);
      case "after":
        return v.on(_, L);
    }
  }
  function b() {
    t && (t = !1, S(), E());
  }
  function y() {
    t = !0, S(), cancelAnimationFrame(i);
  }
  function d() {
    n = !1, S();
  }
  function C() {
    n = !0, S();
  }
  function M() {
    l.value = !0;
  }
  function P() {
    l.value = !1;
  }
  function E() {
    if (!e) {
      i = requestAnimationFrame(E);
      return;
    }
    const _ = r.getDelta(), A = r.getElapsedTime(), L = {
      camera: J(f.camera),
      scene: J(f.scene),
      renderer: J(f.renderer),
      raycaster: J(f.raycaster),
      controls: J(f.controls),
      invalidate: f.invalidate,
      advance: f.advance
    }, p = { delta: _, elapsed: A, clock: r, ...L };
    s.value && o.trigger(p), l.value || (u.count ? u.trigger(p) : c && c(p)), s.value && v.trigger(p), i = requestAnimationFrame(E);
  }
  function S() {
    const _ = !t && !n;
    r.running !== _ && (r.running ? r.stop() : r.start()), s.value = r.running;
  }
  return {
    loopId: a,
    register: (_, A, L) => g(_, A, L),
    start: b,
    stop: y,
    pause: C,
    resume: d,
    pauseRender: M,
    resumeRender: P,
    isRenderPaused: l,
    isActive: s,
    setContext: h,
    setReady: (_) => e = _
  };
}
function hr(e, t, n = 100) {
  n = n <= 0 ? 100 : n;
  const r = j(), s = /* @__PURE__ */ new Set();
  let l = !1, i = !1, a = null;
  function c() {
    a && clearTimeout(a), !i && !l && e() ? (r.trigger(t), s.forEach((f) => f()), s.clear(), l = !0) : !i && !l && (a = setTimeout(c, n));
  }
  function o() {
    i = !0, a && clearTimeout(a);
  }
  c();
  const u = (f, ...h) => {
    f(...h);
  };
  return {
    on: (f) => {
      if (l)
        return u(f, t), { off: () => {
        } };
      {
        const h = r.on(f);
        return s.add(h.off), r.on(f);
      }
    },
    off: r.off,
    trigger: r.trigger,
    cancel: o
  };
}
const te = /* @__PURE__ */ new WeakMap();
function gt(e) {
  if (e = e || pe(), te.has(e))
    return te.get(e);
  const t = 100, n = Date.now(), l = hr(() => {
    if (Date.now() - n >= t)
      return !0;
    {
      const i = e.renderer.value, a = (i == null ? void 0 : i.domElement) || { width: 0, height: 0 };
      return !!(i && a.width > 0 && a.height > 0);
    }
  }, e);
  return te.set(e, l), l;
}
function Yr(e) {
  const t = pe();
  if (t)
    return te.has(t) ? te.get(t).on(e) : gt(t).on(e);
}
function gr({
  scene: e,
  canvas: t,
  windowSize: n,
  disableRender: r,
  rendererOptions: s,
  emit: l
}) {
  const i = $(e), a = pr(n, t), {
    camera: c,
    cameras: o,
    registerCamera: u,
    deregisterCamera: v,
    setCameraActive: f
  } = In({ sizes: a, scene: e }), h = {
    mode: H(s.renderMode || "always"),
    priority: H(0),
    frames: H(0),
    maxFrames: 60,
    canBeInvalidated: V(() => h.mode.value === "on-demand" && h.frames.value === 0)
  };
  function g(O = 1) {
    s.renderMode === "on-demand" && (h.frames.value = Math.min(h.maxFrames, h.frames.value + O));
  }
  function b() {
    s.renderMode === "manual" && (h.frames.value = 1);
  }
  const { renderer: y } = ar(
    {
      scene: e,
      canvas: t,
      options: s,
      emit: l,
      // TODO: replace contextParts with full ctx at https://github.com/Tresjs/tres/issues/516
      contextParts: { sizes: a, camera: c, render: h, invalidate: g, advance: b },
      disableRender: r
    }
  ), d = {
    sizes: a,
    scene: i,
    camera: c,
    cameras: ye(o),
    renderer: y,
    raycaster: $(new Ft()),
    controls: H(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    render: h,
    advance: b,
    extend: Me,
    invalidate: g,
    registerCamera: u,
    setCameraActive: f,
    deregisterCamera: v,
    loop: mr()
  };
  _e("useTres", d), d.scene.value.__tres = {
    root: d
  }, d.loop.register(() => {
    c.value && h.frames.value > 0 && (y.value.render(e, c.value), l("render", d.renderer.value)), h.priority.value = 0, h.mode.value === "always" ? h.frames.value = 1 : h.frames.value = Math.max(0, h.frames.value - 1);
  }, "render");
  const { on: C, cancel: M } = gt(d);
  d.loop.setReady(!1), d.loop.start(), C(() => {
    l("ready", d), d.loop.setReady(!0), dr(e, d, l);
  }), K(() => {
    M(), d.loop.stop();
  });
  const P = 100, E = an({ every: P }), { isSupported: S, memory: _ } = ln({ interval: P }), A = 160;
  let L = performance.now();
  const p = ({ timestamp: O }) => {
    d.scene.value && (d.perf.memory.allocatedMem = xe(d.scene.value)), O - L >= P && (L = O, d.perf.fps.accumulator.push(E.value), d.perf.fps.accumulator.length > A && d.perf.fps.accumulator.shift(), d.perf.fps.value = E.value, S.value && _.value && (d.perf.memory.accumulator.push(_.value.usedJSHeapSize / 1024 / 1024), d.perf.memory.accumulator.length > A && d.perf.memory.accumulator.shift(), d.perf.memory.currentMem = d.perf.memory.accumulator.reduce((B, R) => B + R, 0) / d.perf.memory.accumulator.length));
  };
  let w = 0;
  const x = 1, { pause: D } = it(({ delta: O }) => {
    window.__TRES__DEVTOOLS__ && (p({ timestamp: performance.now() }), w += O, w >= x && (window.__TRES__DEVTOOLS__.cb(d), w = 0));
  }, { immediate: !0 });
  return K(() => {
    D();
  }), d;
}
function pe() {
  const e = Ct("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const qr = pe;
function Jr() {
  const {
    camera: e,
    scene: t,
    renderer: n,
    loop: r,
    raycaster: s,
    controls: l,
    invalidate: i,
    advance: a
  } = pe();
  r.setContext({
    camera: e,
    scene: t,
    renderer: n,
    raycaster: s,
    controls: l,
    invalidate: i,
    advance: a
  });
  function c(v, f = 0) {
    return r.register(v, "before", f);
  }
  function o(v) {
    return r.register(v, "render");
  }
  function u(v, f = 0) {
    return r.register(v, "after", f);
  }
  return {
    pause: r.pause,
    resume: r.resume,
    pauseRender: r.pauseRender,
    resumeRender: r.resumeRender,
    isActive: r.isActive,
    onBeforeRender: c,
    render: o,
    onAfterRender: u
  };
}
function vr(e, t = {}, n = {}) {
  let r = e;
  const s = (a) => {
    r = a;
  };
  let l = new Proxy({}, {});
  const i = {
    has(a, c) {
      return c in t || c in r;
    },
    get(a, c, o) {
      return c in t ? t[c](r) : r[c];
    },
    set(a, c, o) {
      return n[c] ? n[c](o, r, l, s) : r[c] = o, !0;
    }
  };
  return l = new Proxy({}, i), l;
}
const { logError: Ke } = Y(), Qe = [
  "onClick",
  "onContextMenu",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut",
  "onDoubleClick",
  "onPointerDown",
  "onPointerUp",
  "onPointerCancel",
  "onPointerMissed",
  "onLostPointerCapture",
  "onWheel"
], yr = (e) => {
  const t = e.scene.value;
  function n(o, u, v, f) {
    if (f || (f = {}), f.args || (f.args = []), o === "template" || zn(o))
      return null;
    let h = o.replace("Tres", ""), g;
    if (o === "primitive") {
      (!U(f.object) || Mt(f.object)) && Ke(
        "Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"
      ), h = f.object.type;
      const b = {};
      g = vr(
        f.object,
        {
          object: (d) => d,
          isPrimitive: () => !0,
          __tres: () => b
        },
        {
          object: (d, C, M, P) => {
            sr(d, M, P, { patchProp: l, remove: s, insert: r }, e);
          },
          __tres: (d) => {
            Object.assign(b, d);
          }
        }
      );
    } else {
      const b = Ce.value[h];
      b || Ke(
        `${h} is not defined on the THREE namespace. Use extend to add it to the catalog.`
      ), g = new b(...f.args);
    }
    return g ? (g.isCamera && (f != null && f.position || g.position.set(3, 3, 3), f != null && f.lookAt || g.lookAt(0, 0, 0)), g = z(g, {
      ...g.__tres,
      type: h,
      memoizedProps: f,
      eventCount: 0,
      primitive: o === "primitive",
      attach: f.attach
    }, e), g) : null;
  }
  function r(o, u) {
    var h, g, b;
    if (!o)
      return;
    u = u || t;
    const v = o.__tres ? o : z(o, {}, e), f = u.__tres ? u : z(u, {}, e);
    o = Q(v), u = Q(f), o.__tres && ((h = o.__tres) == null ? void 0 : h.eventCount) > 0 && ((g = e.eventManager) == null || g.registerObject(o)), e.registerCamera(o), (b = e.eventManager) == null || b.registerPointerMissedObject(o), v.__tres.attach ? nr(f, v, v.__tres.attach) : N(o) && N(f) && (f.add(o), o.dispatchEvent({ type: "added" })), v.__tres.parent = f, f.__tres.objects && !f.__tres.objects.includes(v) && f.__tres.objects.push(v);
  }
  function s(o, u) {
    var g, b, y, d;
    if (!o)
      return;
    o != null && o.__tres && ((g = o.__tres) == null ? void 0 : g.eventCount) > 0 && ((b = e.eventManager) == null || b.deregisterObject(o)), u = be(u) ? "default" : u;
    const v = (y = o.__tres) == null ? void 0 : y.dispose;
    be(v) || (v === null ? u = !1 : u = v);
    const f = (d = o.__tres) == null ? void 0 : d.primitive, h = u === "default" ? !f : !!u;
    if (o.__tres && "objects" in o.__tres && [...o.__tres.objects].forEach((C) => s(C, u)), h && o.children && [...o.children].forEach((C) => s(C, u)), mt(o, e), ht(o, e), h && !jn(o)) {
      if (G(u))
        u(o);
      else if (G(o.dispose))
        try {
          o.dispose();
        } catch {
        }
    }
    "__tres" in o && delete o.__tres;
  }
  function l(o, u, v, f) {
    var C, M;
    if (!o)
      return;
    let h = o, g = u;
    if (o.__tres && (o.__tres.memoizedProps[u] = f), u === "attach") {
      const P = ((C = o.__tres) == null ? void 0 : C.parent) || o.parent;
      s(o), z(o, { attach: f }, e), P && r(o, P);
      return;
    }
    if (u === "dispose") {
      o.__tres || (o = z(o, {}, e)), o.__tres.dispose = f;
      return;
    }
    if (N(o) && g === "blocks-pointer-events") {
      f || f === "" ? o[g] = f : delete o[g];
      return;
    }
    Qe.includes(u) && o.__tres && (o.__tres.eventCount += 1);
    let b = ie(g), y = h == null ? void 0 : h[b];
    if (g === "args") {
      const P = o, E = v ?? [], S = f ?? [], _ = ((M = o.__tres) == null ? void 0 : M.type) || o.type;
      _ && E.length && !Jn(E, S) && (h = Object.assign(
        P,
        new Ce.value[_](...f)
      ));
      return;
    }
    if (h.type === "BufferGeometry") {
      if (g === "args")
        return;
      h.setAttribute(
        ie(g),
        new Wt(...f)
      );
      return;
    }
    if (g.includes("-") && y === void 0) {
      const P = g.split("-");
      y = P.reduce((E, S) => E[ie(S)], h), g = P.pop(), b = g, y != null && y.set || (h = P.reduce((E, S) => E[ie(S)], h));
    }
    let d = f;
    if (d === "" && (d = !0), G(y)) {
      Qe.includes(u) || (de(d) ? o[b](...d) : o[b](d)), b.startsWith("on") && G(d) && (h[b] = d);
      return;
    }
    !(y != null && y.set) && !G(y) ? h[b] = d : y.constructor === d.constructor && (y != null && y.copy) ? y == null || y.copy(d) : de(d) ? y.set(...d) : !y.isColor && y.setScalar ? y.setScalar(d) : y.set(d), pt(o);
  }
  function i(o) {
    var u;
    return ((u = o == null ? void 0 : o.__tres) == null ? void 0 : u.parent) || null;
  }
  function a(o) {
    const u = z(new Nt(), { type: "Comment" }, e);
    return u.name = o, u;
  }
  function c(o) {
    var h;
    const u = i(o), v = ((h = u == null ? void 0 : u.__tres) == null ? void 0 : h.objects) || [], f = v.indexOf(o);
    return f < 0 || f >= v.length - 1 ? null : v[f + 1];
  }
  return {
    insert: r,
    remove: s,
    createElement: n,
    patchProp: l,
    parentNode: i,
    createText: () => void 0,
    createComment: a,
    setText: () => void 0,
    setElementText: () => void 0,
    nextSibling: c,
    querySelector: () => void 0,
    setScopeId: () => void 0,
    cloneNode: () => void 0,
    insertStaticContent: () => void 0
  };
};
function _r() {
  return vt().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function vt() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const wr = typeof Proxy == "function", br = "devtools-plugin:setup", Pr = "plugin:settings:set";
let q, Ee;
function Cr() {
  var e;
  return q !== void 0 || (typeof window < "u" && window.performance ? (q = !0, Ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (q = !0, Ee = globalThis.perf_hooks.performance) : q = !1), q;
}
function Mr() {
  return Cr() ? Ee.now() : Date.now();
}
class Er {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const r = {};
    if (t.settings)
      for (const i in t.settings) {
        const a = t.settings[i];
        r[i] = a.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${t.id}`;
    let l = Object.assign({}, r);
    try {
      const i = localStorage.getItem(s), a = JSON.parse(i);
      Object.assign(l, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return l;
      },
      setSettings(i) {
        try {
          localStorage.setItem(s, JSON.stringify(i));
        } catch {
        }
        l = i;
      },
      now() {
        return Mr();
      }
    }, n && n.on(Pr, (i, a) => {
      i === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (i, a) => this.target ? this.target.on[a] : (...c) => {
        this.onQueue.push({
          method: a,
          args: c
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (i, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...c) => (this.targetQueue.push({
        method: a,
        args: c,
        resolve: () => {
        }
      }), this.fallbacks[a](...c)) : (...c) => new Promise((o) => {
        this.targetQueue.push({
          method: a,
          args: c,
          resolve: o
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function Tr(e, t) {
  const n = e, r = vt(), s = _r(), l = wr && n.enableEarlyProxy;
  if (s && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !l))
    s.emit(br, e, t);
  else {
    const i = l ? new Er(n, s) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: i
    }), i && t(i.proxiedTarget);
  }
}
function Sr(e, t) {
  const n = `▲ ■ ●${e}`;
  typeof Xe == "function" ? Xe(n, t) : console.log(n);
}
function Xe(e, t) {
  throw new Error(e + t);
}
const yt = (e) => {
  const t = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && t.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const n = xe(e);
  return n > 0 && t.tags.push({
    label: `${fr(n)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (On(e) && t.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), t.tags.push({
    label: `#${new Z(e.color).getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (t.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), t.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), t;
};
function _t(e, t, n = "") {
  e.children.forEach((r) => {
    if (r.type === "HightlightMesh" || n && !r.type.includes(n) && !r.name.includes(n))
      return;
    const s = yt(r);
    t.children.push(s), _t(r, s, n);
  });
}
const Ar = [], X = "tres:inspector", xr = Et({
  sceneGraph: null
});
function kr(e, t) {
  Tr(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Ar,
      app: e
    },
    (n) => {
      typeof n.now != "function" && Sr(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), n.addInspector({
        id: X,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        n.sendInspectorTree(X);
      }, 1e3), setInterval(() => {
        n.notifyComponentUpdate();
      }, 5e3), n.on.getInspectorTree((l) => {
        if (l.inspectorId === X) {
          const i = yt(t.scene.value);
          _t(t.scene.value, i, l.filter), xr.sceneGraph = i, l.rootNodes = [i];
        }
      });
      let r = null, s = null;
      n.on.getInspectorState((l) => {
        var i;
        if (l.inspectorId === X) {
          const [a] = t.scene.value.getObjectsByProperty("uuid", l.nodeId);
          if (!a)
            return;
          if (s && r && r.parent && s.remove(r), a.isMesh) {
            const c = Xn(a);
            a.add(c), r = c, s = a;
          }
          l.state = {
            object: Object.entries(a).map(([c, o]) => c === "children" ? { key: c, value: o.filter((u) => u.type !== "HightlightMesh") } : { key: c, value: o, editable: !0 }).filter(({ key: c }) => c !== "parent")
          }, a.isScene && (l.state.info = {
            memory: xe(a),
            objects: a.children.length,
            calls: t.renderer.value.info.render.calls,
            triangles: t.renderer.value.info.render.triangles,
            points: t.renderer.value.info.render.points,
            lines: t.renderer.value.info.render.lines
          }, l.state.programs = ((i = t.renderer.value.info.programs) == null ? void 0 : i.map((c) => ({
            key: c.name,
            value: {
              ...c,
              vertexShader: c.vertexShader,
              attributes: c.getAttributes(),
              uniforms: c.getUniforms()
            }
          }))) || []);
        }
      }), n.on.editInspectorState((l) => {
        l.inspectorId === X && Qn(t.scene.value, l.nodeId, l.path, l.state.value);
      });
    }
  );
}
const Lr = ["data-scene", "data-tres"], Rr = /* @__PURE__ */ Be({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    renderMode: { default: "always" },
    dpr: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  emits: [
    "render",
    "click",
    "double-click",
    "context-menu",
    "pointer-move",
    "pointer-up",
    "pointer-down",
    "pointer-enter",
    "pointer-leave",
    "pointer-over",
    "pointer-out",
    "pointer-missed",
    "wheel",
    "ready"
  ],
  setup(e, { expose: t, emit: n }) {
    var y;
    const r = e, s = n, l = Tt(), { logWarning: i } = Y(), a = H(), c = $(new nt()), o = (y = Ie()) == null ? void 0 : y.appContext.app;
    Me(et);
    const u = (d, C = !1) => Be({
      setup() {
        var P;
        const M = (P = Ie()) == null ? void 0 : P.appContext;
        return M && (M.app = o), _e("useTres", d), _e("extend", Me), typeof window < "u" && kr(M == null ? void 0 : M.app, d), () => He(Ot, null, C ? [] : l.default());
      }
    }), v = (d, C = !1) => {
      const M = u(d, C), { render: P } = Rt(yr(d));
      P(He(M), c.value);
    }, f = (d, C = !1) => {
      dt(d.scene.value), C && (d.renderer.value.dispose(), d.renderer.value.renderLists.dispose(), d.renderer.value.forceContextLoss()), c.value.__tres = {
        root: d
      };
    }, h = V(() => r.disableRender), g = $(null);
    t({ context: g, dispose: () => f(g.value, !0) });
    const b = () => {
      f(g.value), v(g.value, !0);
    };
    return St(() => {
      const d = a;
      g.value = gr({
        scene: c.value,
        canvas: d,
        windowSize: r.windowSize ?? !1,
        disableRender: h.value ?? !1,
        rendererOptions: r,
        emit: s
      });
      const { registerCamera: C, camera: M, cameras: P, deregisterCamera: E } = g.value;
      v(g.value);
      const S = () => {
        const _ = new we(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        _.position.set(3, 3, 3), _.lookAt(0, 0, 0), C(_);
        const A = Te(() => {
          P.value.length >= 2 && (_.removeFromParent(), E(_), A == null || A());
        });
      };
      ce(
        () => r.camera,
        (_, A) => {
          _ && C(_), A && (A.removeFromParent(), E(A));
        },
        {
          immediate: !0
        }
      ), M.value || (i(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), S());
    }), K(b), (d, C) => (At(), xt("canvas", {
      ref_key: "canvas",
      ref: a,
      "data-scene": c.value.uuid,
      class: kt(d.$attrs.class),
      "data-tres": `tresjs ${J(xn).version}`,
      style: Lt({
        display: "block",
        width: "100%",
        height: "100%",
        position: d.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...d.$attrs.style
      })
    }, null, 14, Lr));
  }
}), Or = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], Dr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Or.includes(e) || e === "primitive"
    }
  }
}, Kr = Dr, Qr = {
  mounted: (e, t) => {
    if (t.arg) {
      console.log(`v-log:${t.arg}`, e[t.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
class wt extends zt {
  constructor(t, n) {
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new $e();
    s.setAttribute("position", new Ue(r, 3)), s.computeBoundingSphere();
    const l = new Gt({ fog: !1 });
    super(s, l), this.light = t, this.color = n, this.type = "RectAreaLightHelper";
    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new $e();
    a.setAttribute("position", new Ue(i, 3)), a.computeBoundingSphere(), this.add(new Vt(a, new ot({ side: Yt, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const t = this.material.color, n = Math.max(t.r, t.g, t.b);
      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const { logWarning: Ze } = Y();
let le, W;
const jr = {
  DirectionalLight: qt,
  PointLight: Jt,
  SpotLight: Kt,
  HemisphereLight: Qt,
  RectAreaLight: wt
}, Xr = {
  mounted: (e) => {
    if (!e.isLight) {
      Ze(`${e.type} is not a light`);
      return;
    }
    le = jr[e.type], e.parent.add(new le(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    W = e.parent.children.find((t) => t instanceof le), !(W instanceof wt) && W.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      Ze(`${e.type} is not a light`);
      return;
    }
    W = e.parent.children.find((t) => t instanceof le), W && W.dispose && W.dispose(), e.parent.remove(W);
  }
}, { logWarning: Br } = Y();
let I = null;
const Zr = {
  updated: (e, t) => {
    var s;
    const n = Zn(t);
    if (!n) {
      Br(`v-distance-to: problem with binding value: ${t.value}`);
      return;
    }
    I && (I.dispose(), e.parent.remove(I));
    const r = n.clone().sub(e.position);
    r.normalize(), I = new Xt(r, e.position, e.position.distanceTo(n), 16776960), e.parent.add(I), console.table(
      [
        ["Distance:", e.position.distanceTo(n)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${n.x}, y:${n.y}, z:${n == null ? void 0 : n.z}`]
      ]
    );
  },
  unmounted: (e) => {
    I == null || I.dispose(), e.parent.remove(I);
  }
}, eo = {
  install(e) {
    e.component("TresCanvas", Rr);
  }
};
export {
  Rr as TresCanvas,
  Ce as catalogue,
  mr as createRenderLoop,
  eo as default,
  dt as dispose,
  Me as extend,
  Wr as isProd,
  Fn as normalizeColor,
  Nr as normalizeVectorFlexibleParam,
  Yr as onTresReady,
  Kr as templateCompilerOptions,
  cr as trasverseObjects,
  In as useCamera,
  zr as useLoader,
  Y as useLogger,
  Jr as useLoop,
  ur as useRaycaster,
  Fr as useRenderLoop,
  ar as useRenderer,
  Vr as useSeek,
  Gr as useTexture,
  qr as useTres,
  pe as useTresContext,
  gr as useTresContextProvider,
  dr as useTresEventManager,
  Zr as vDistanceTo,
  Xr as vLightHelper,
  Qr as vLog
};
