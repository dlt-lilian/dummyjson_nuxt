/**
 * name: @tresjs/core
 * version: v4.1.0
 * (c) 2024
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var gt = Object.defineProperty;
var ht = (e, t, n) => t in e ? gt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var ue = (e, t, n) => (ht(e, typeof t != "symbol" ? t + "" : t, n), n);
import { ref as D, computed as j, watchEffect as Me, onUnmounted as Y, shallowRef as $, watch as J, reactive as Ke, readonly as me, unref as V, provide as ge, inject as vt, defineComponent as Le, useSlots as yt, getCurrentInstance as Re, onMounted as wt, openBlock as bt, createElementBlock as Mt, normalizeClass as _t, normalizeStyle as Pt, createRenderer as Ct, h as De, Fragment as Et } from "vue";
import * as Xe from "three";
import { PerspectiveCamera as he, Camera as kt, Clock as Ze, Vector3 as _e, Color as se, Scene as et, MeshBasicMaterial as tt, DoubleSide as St, REVISION as Tt, SRGBColorSpace as At, ACESFilmicToneMapping as nt, PCFSoftShadowMap as Ot, NoToneMapping as xt, WebGLRenderer as fe, TextureLoader as Lt, Vector2 as de, MathUtils as Rt, Raycaster as Dt, BufferAttribute as Bt, Object3D as jt, Line as It, BufferGeometry as Be, Float32BufferAttribute as je, LineBasicMaterial as Ht, Mesh as Ut, BackSide as $t, DirectionalLightHelper as Ft, PointLightHelper as Wt, SpotLightHelper as Nt, HemisphereLightHelper as Gt, ArrowHelper as zt } from "three";
import { createEventHook as L, useRafFn as rt, toValue as A, unrefElement as Vt, useDevicePixelRatio as Yt, usePointer as qt, useElementBounding as Jt, useWindowSize as Qt, useElementSize as Kt, refDebounced as Ie, tryOnScopeDispose as Xt, useFps as Zt, useMemory as en } from "@vueuse/core";
const tn = "@tresjs/core", nn = "module", rn = "4.1.0", on = "pnpm@9.1.4", sn = "Declarative ThreeJS using Vue Components", an = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", ln = "MIT", cn = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
], un = !1, fn = {
  ".": {
    types: "./dist/index.d.ts",
    import: "./dist/tres.js",
    require: "./dist/tres.umd.cjs"
  },
  "./components": {
    types: "./dist/src/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/src/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/src/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/src/utils/index.d.ts"
  },
  "./*": "./*"
}, dn = "./dist/tres.js", pn = "./dist/tres.js", mn = "./dist/index.d.ts", gn = [
  "*.d.ts",
  "dist"
], hn = {
  access: "public"
}, vn = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui --coverage.enabled=true",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint .",
  "lint:fix": "eslint . --fix",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts",
  prepare: "node .husky/install.mjs"
}, yn = {
  three: ">=0.133",
  vue: ">=3.4"
}, wn = {
  "@alvarosabu/utils": "^3.2.0",
  "@vue/devtools-api": "^6.6.2",
  "@vueuse/core": "^10.10.0"
}, bn = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.10.0",
  "@tresjs/cientos": "3.9.0",
  "@tresjs/eslint-config": "^1.1.0",
  "@types/three": "^0.165.0",
  "@typescript-eslint/eslint-plugin": "^7.11.0",
  "@typescript-eslint/parser": "^7.11.0",
  "@vitejs/plugin-vue": "^5.0.5",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/coverage-v8": "^1.6.0",
  "@vitest/ui": "^1.6.0",
  "@vue/test-utils": "^2.4.6",
  eslint: "^9.4.0",
  "eslint-plugin-vue": "^9.26.0",
  esno: "^4.7.0",
  gsap: "^3.12.5",
  husky: "^9.0.11",
  jsdom: "^24.1.0",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.2",
  "release-it": "^17.3.0",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.12.0",
  sponsorkit: "^0.14.6",
  three: "^0.165.0",
  unocss: "^0.60.4",
  unplugin: "^1.10.1",
  "unplugin-vue-components": "^0.27.0",
  vite: "^5.2.12",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.9.1",
  "vite-plugin-inspect": "^0.8.4",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.2.2",
  vitest: "^1.6.0",
  vue: "^3.4.27",
  "vue-demi": "^0.14.8"
}, Mn = {
  name: tn,
  type: nn,
  version: rn,
  packageManager: on,
  description: sn,
  author: an,
  license: ln,
  keywords: cn,
  sideEffects: un,
  exports: fn,
  main: dn,
  module: pn,
  types: mn,
  files: gn,
  publishConfig: hn,
  scripts: vn,
  peerDependencies: yn,
  dependencies: wn,
  devDependencies: bn
};
function ve(e) {
  return Array.isArray(e);
}
function Q(e) {
  return typeof e == "function";
}
function Z(e) {
  return e === Object(e) && !ve(e) && !Q(e);
}
function W(e) {
  return Z(e) && "isObject3D" in e && !!e.isObject3D;
}
function He(e) {
  return Z(e) && "isCamera" in e && !!e.isCamera;
}
function _n(e) {
  return Z(e) && "isBufferGeometry" in e && !!e.isBufferGeometry;
}
function Pn(e) {
  return Z(e) && "isMaterial" in e && !!e.isMaterial;
}
function ot(e) {
  return Z(e) && "isFog" in e && !!e.isFog;
}
function Ue(e) {
  return W(e) || _n(e) || Pn(e) || ot(e);
}
const Cn = ({ sizes: e }) => {
  const t = D([]), n = j(
    () => t.value[0]
  ), r = (i) => {
    const a = i instanceof kt ? i : t.value.find((o) => o.uuid === i);
    if (!a)
      return;
    const d = t.value.filter(({ uuid: o }) => o !== a.uuid);
    t.value = [a, ...d];
  }, s = (i, a = !1) => {
    if (He(i)) {
      const d = i;
      if (t.value.some(({ uuid: o }) => o === d.uuid))
        return;
      a ? r(d) : t.value.push(d);
    }
  }, l = (i) => {
    if (He(i)) {
      const a = i;
      t.value = t.value.filter(({ uuid: d }) => d !== a.uuid);
    }
  };
  return Me(() => {
    e.aspectRatio.value && t.value.forEach((i) => {
      !i.manual && (i instanceof he || En(i)) && (i instanceof he ? i.aspect = e.aspectRatio.value : (i.left = e.width.value * -0.5, i.right = e.width.value * 0.5, i.top = e.height.value * 0.5, i.bottom = e.height.value * -0.5), i.updateProjectionMatrix());
    });
  }), Y(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    registerCamera: s,
    deregisterCamera: l,
    setCameraActive: r
  };
};
function En(e) {
  return e.hasOwnProperty("isOrthographicCamera") && e.isOrthographicCamera;
}
const it = L(), st = L(), Pe = L(), K = new Ze();
let ae = 0, le = 0;
const { pause: kn, resume: $e, isActive: Sn } = rt(
  () => {
    it.trigger({ delta: ae, elapsed: le, clock: K }), st.trigger({ delta: ae, elapsed: le, clock: K }), Pe.trigger({ delta: ae, elapsed: le, clock: K });
  },
  { immediate: !1 }
);
Pe.on(() => {
  ae = K.getDelta(), le = K.getElapsedTime();
});
let Fe = !1;
const Pr = () => (Fe || (Fe = !0, $e()), {
  onBeforeLoop: it.on,
  onLoop: st.on,
  onAfterLoop: Pe.on,
  pause: kn,
  resume: $e,
  isActive: Sn
}), Cr = !0, ne = "[TresJS ▲ ■ ●] ";
function F() {
  function e(...r) {
    typeof r[0] == "string" ? r[0] = ne + r[0] : r.unshift(ne), console.error(...r);
  }
  function t(...r) {
    typeof r[0] == "string" ? r[0] = ne + r[0] : r.unshift(ne), console.warn(...r);
  }
  function n(r, s) {
  }
  return {
    logError: e,
    logWarning: t,
    logMessage: n
  };
}
function Er(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof _e ? [e.x, e.y, e.z] : e;
}
function Tn(e) {
  return e instanceof se ? e : Array.isArray(e) ? new se(...e) : new se(e);
}
class An extends Xe.Mesh {
  constructor(...n) {
    super(...n);
    ue(this, "type", "HightlightMesh");
    ue(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const r = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * r);
    this.scale.set(i, i, i);
  }
}
const at = (e, t) => {
  for (const n of Object.keys(t))
    t[n] instanceof Object && Object.assign(t[n], at(e[n], t[n]));
  return Object.assign(e || {}, t), e;
}, On = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", xn = /* @__PURE__ */ Dn(On);
function We(e) {
  return e && e.nodeType === 1;
}
function re(e) {
  return e.replace(/-([a-z])/g, (t, n) => n.toUpperCase());
}
const Ln = /\B([A-Z])/g;
function Rn(e) {
  return e.replace(Ln, "-$1").toLowerCase();
}
function Dn(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let s = 0; s < r.length; s++)
    n[r[s]] = !0;
  return (s) => !!n[s];
}
const Bn = (e, t) => {
  const n = /* @__PURE__ */ new Set(), r = [];
  for (const s of e) {
    const l = t(s);
    n.has(l) || (n.add(l), r.push(s));
  }
  return r;
}, Ne = (e, t) => {
  if (!t)
    return;
  const n = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
  return n == null ? void 0 : n.reduce((r, s) => r && r[s], e);
}, jn = (e, t, n) => {
  const r = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
  r && r.reduce((s, l, i) => (s[l] === void 0 && (s[l] = {}), i === r.length - 1 && (s[l] = n), s[l]), e);
};
function lt(e, t) {
  if (We(e) && We(t)) {
    const s = e.attributes, l = t.attributes;
    return s.length !== l.length ? !1 : Array.from(s).every(({ name: i, value: a }) => t.getAttribute(i) === a);
  }
  if (e === t)
    return !0;
  if (e === null || typeof e != "object" || t === null || typeof t != "object")
    return !1;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (const s of n)
    if (!r.includes(s) || !lt(e[s], t[s]))
      return !1;
  return !0;
}
function In(e, t) {
  if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!lt(e[n], t[n]))
      return !1;
  return !0;
}
const Hn = Array.isArray;
function Un(e, t, n, r) {
  const s = (d) => {
    if (d.uuid === t)
      return d;
    for (const o of d.children) {
      const h = s(o);
      if (h)
        return h;
    }
  }, l = s(e);
  if (!l) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let i = l;
  for (let d = 0; d < n.length - 1; d++)
    if (i[n[d]] !== void 0)
      i = i[n[d]];
    else {
      console.warn(`Property path is not valid: ${n.join(".")}`);
      return;
    }
  const a = n[n.length - 1];
  i[a] !== void 0 ? i[a] = r : console.warn(`Property path is not valid: ${n.join(".")}`);
}
function $n(e) {
  const t = new tt({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: !0,
    opacity: 0.2,
    depthTest: !1,
    // So the highlight is always visible
    side: St
    // To e
  });
  return new An(e.geometry.clone(), t);
}
function Fn(e) {
  var n;
  let t = e.value;
  return e.value && ((n = e.value) != null && n.isMesh) && (t = e.value.position), Array.isArray(e.value) && (t = new _e(...t)), t;
}
function Wn(e) {
  return "map" in e;
}
function Ge(e) {
  Wn(e) && e.map && e.map.dispose(), e.dispose();
}
function Ce(e) {
  var n, r;
  if (e.parent && ((n = e.removeFromParent) == null || n.call(e)), delete e.__tres, [...e.children].forEach((s) => Ce(s)), !(e instanceof et)) {
    const s = e;
    e && ((r = e.dispose) == null || r.call(e)), s.geometry && (s.geometry.dispose(), delete s.geometry), Array.isArray(s.material) ? (s.material.forEach((l) => Ge(l)), delete s.material) : s.material && (Ge(s.material), delete s.material);
  }
}
function Nn(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    t(e[r], r) && (e[n] = e[r], n++);
  return e.length = n, e;
}
const Gn = Number.parseInt(Tt.replace("dev", "")), oe = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: At,
    toneMapping: nt,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Ot
    }
  },
  flat: {
    toneMapping: xt,
    toneMappingExposure: 1
  }
};
function zn({
  canvas: e,
  options: t,
  contextParts: { sizes: n, render: r, invalidate: s, advance: l }
}) {
  const i = j(() => ({
    alpha: A(t.alpha) ?? !0,
    depth: A(t.depth),
    canvas: Vt(e),
    context: A(t.context),
    stencil: A(t.stencil),
    antialias: A(t.antialias) ?? !0,
    precision: A(t.precision),
    powerPreference: A(t.powerPreference),
    premultipliedAlpha: A(t.premultipliedAlpha),
    preserveDrawingBuffer: A(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: A(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: A(t.failIfMajorPerformanceCaveat)
  })), a = $(new fe(i.value));
  function d() {
    t.renderMode === "on-demand" && s();
  }
  J(i, () => {
    a.value.dispose(), a.value = new fe(i.value), d();
  }), J([n.width, n.height], () => {
    a.value.setSize(n.width.value, n.height.value), d();
  }, {
    immediate: !0
  }), J(() => t.clearColor, d);
  const { pixelRatio: o } = Yt();
  J(o, () => {
    a.value.setPixelRatio(o.value);
  });
  const { logError: h } = F(), c = (() => {
    const f = new fe(), _ = {
      shadowMap: {
        enabled: f.shadowMap.enabled,
        type: f.shadowMap.type
      },
      toneMapping: f.toneMapping,
      toneMappingExposure: f.toneMappingExposure,
      outputColorSpace: f.outputColorSpace
    };
    return f.dispose(), _;
  })(), v = A(t.renderMode);
  return v === "on-demand" && s(), v === "manual" && setTimeout(() => {
    l();
  }, 100), Me(() => {
    const f = A(t.preset);
    f && (f in oe || h(`Renderer Preset must be one of these: ${Object.keys(oe).join(", ")}`), at(a.value, oe[f])), v === "always" && (r.frames.value = Math.max(1, r.frames.value));
    const _ = (y, k) => {
      const P = A(y), C = () => {
        if (f)
          return Ne(oe[f], k);
      };
      if (P !== void 0)
        return P;
      const b = C();
      return b !== void 0 ? b : Ne(c, k);
    }, m = (y, k) => jn(a.value, k, _(y, k));
    m(t.shadows, "shadowMap.enabled"), m(t.toneMapping ?? nt, "toneMapping"), m(t.shadowMapType, "shadowMap.type"), Gn < 150 && m(!t.useLegacyLights, "physicallyCorrectLights"), m(t.outputColorSpace, "outputColorSpace"), m(t.toneMappingExposure, "toneMappingExposure");
    const w = _(t.clearColor, "clearColor");
    w && a.value.setClearColor(
      w ? Tn(w) : new se(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  }), Y(() => {
    a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
const Vn = (e) => !!e && e.constructor === Array;
function Yn(e) {
  const t = { nodes: {}, materials: {} };
  return e && e.traverse((n) => {
    n.name && (t.nodes[n.name] = n), n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material);
  }), t;
}
async function kr(e, t, n, r, s) {
  const { logError: l } = F(), i = new e();
  s && s(i), n && n(i);
  const d = (Array.isArray(t) ? t : [t]).map(
    (o) => new Promise((h, p) => {
      i.load(
        o,
        (c) => {
          c.scene && Object.assign(c, Yn(c.scene)), h(c);
        },
        r,
        (c) => p(l("[useLoader] - Failed to load resource", c))
      );
    })
  );
  return Vn(t) ? await Promise.all(d) : await d[0];
}
async function Sr(e, t) {
  const n = new Lt(t), r = (s) => new Promise((l, i) => {
    n.load(
      s,
      (a) => l(a),
      () => null,
      () => {
        i(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Hn(e)) {
    const s = await Promise.all(e.map((l) => r(l)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: l,
      normalMap: i,
      roughnessMap: a,
      metalnessMap: d,
      aoMap: o,
      alphaMap: h,
      matcap: p
    } = e;
    return {
      map: s ? await r(s) : null,
      displacementMap: l ? await r(l) : null,
      normalMap: i ? await r(i) : null,
      roughnessMap: a ? await r(a) : null,
      metalnessMap: d ? await r(d) : null,
      aoMap: o ? await r(o) : null,
      alphaMap: h ? await r(h) : null,
      matcap: p ? await r(p) : null
    };
  }
}
const ct = (e, t) => {
  const n = j(() => t.renderer.value.domElement), r = $([]), { x: s, y: l } = qt({ target: n });
  let i = 0;
  const { width: a, height: d, top: o, left: h } = Jt(n), p = ({ x: g, y: S }) => {
    if (n.value)
      return {
        x: (g - h.value) / a.value * 2 - 1,
        y: -((S - o.value) / d.value) * 2 + 1
      };
  }, c = ({ x: g, y: S }) => {
    if (t.camera.value)
      return t.raycaster.value.setFromCamera(new de(g, S), t.camera.value), r.value = t.raycaster.value.intersectObjects(e.value, !0), r.value;
  }, v = (g) => {
    const S = p({
      x: (g == null ? void 0 : g.clientX) ?? s.value,
      y: (g == null ? void 0 : g.clientY) ?? l.value
    });
    return S ? c(S) || [] : [];
  }, f = L(), _ = L(), m = L(), w = L(), y = L(), k = L(), P = L(), C = L();
  function b(g) {
    const S = {};
    for (const H in g)
      typeof H != "function" && (S[H] = g[H]);
    return S;
  }
  const u = (g, S) => {
    var Ae, Oe, xe;
    const H = b(S), te = new _e(S == null ? void 0 : S.clientX, S == null ? void 0 : S.clientY, 0).unproject((Ae = t.camera) == null ? void 0 : Ae.value);
    g.trigger({
      ...H,
      intersections: r.value,
      // The unprojectedPoint is wrong, math needs to be fixed
      unprojectedPoint: te,
      ray: (Oe = t.raycaster) == null ? void 0 : Oe.value.ray,
      camera: (xe = t.camera) == null ? void 0 : xe.value,
      sourceEvent: S,
      delta: i,
      stopPropagating: !1
    });
  };
  let M;
  const E = (g) => {
    v(g), u(m, g), M = g;
  }, T = () => {
    M && E(M);
  };
  let I, O, x;
  const N = (g) => {
    var S;
    I = (S = r.value[0]) == null ? void 0 : S.object, i = 0, O = new de(
      (g == null ? void 0 : g.clientX) ?? s.value,
      (g == null ? void 0 : g.clientY) ?? l.value
    ), u(y, g);
  };
  let R, G = !1;
  const ee = (g) => {
    var S, H, te;
    g instanceof PointerEvent && (r.value.length === 0 && u(k, g), I === ((S = r.value[0]) == null ? void 0 : S.object) && (x = new de(
      (g == null ? void 0 : g.clientX) ?? s.value,
      (g == null ? void 0 : g.clientY) ?? l.value
    ), i = O == null ? void 0 : O.distanceTo(x), g.button === 0 ? (u(f, g), R === ((H = r.value[0]) == null ? void 0 : H.object) ? G = !0 : (R = (te = r.value[0]) == null ? void 0 : te.object, G = !1)) : g.button === 2 && u(P, g)), u(w, g));
  }, ke = (g) => {
    G && (u(_, g), R = void 0, G = !1);
  }, Se = (g) => u(m, g), Te = (g) => u(C, g);
  return n.value.addEventListener("pointerup", ee), n.value.addEventListener("pointerdown", N), n.value.addEventListener("pointermove", E), n.value.addEventListener("pointerleave", Se), n.value.addEventListener("dblclick", ke), n.value.addEventListener("wheel", Te), Y(() => {
    n != null && n.value && (n.value.removeEventListener("pointerup", ee), n.value.removeEventListener("pointerdown", N), n.value.removeEventListener("pointermove", E), n.value.removeEventListener("pointerleave", Se), n.value.removeEventListener("dblclick", ke), n.value.removeEventListener("wheel", Te));
  }), {
    intersects: r,
    onClick: (g) => f.on(g).off,
    onDblClick: (g) => _.on(g).off,
    onContextMenu: (g) => P.on(g).off,
    onPointerMove: (g) => m.on(g).off,
    onPointerUp: (g) => w.on(g).off,
    onPointerDown: (g) => y.on(g).off,
    onPointerMissed: (g) => k.on(g).off,
    onWheel: (g) => C.on(g).off,
    forceUpdate: T
  };
};
function Tr() {
  const { logWarning: e } = F();
  function t(l, i, a) {
    let d = null;
    return l.traverse((o) => {
      o[i] === a && (d = o);
    }), d || e(`Child with ${i} '${a}' not found.`), d;
  }
  function n(l, i, a) {
    const d = [];
    return l.traverse((o) => {
      o[i].includes(a) && d.push(o);
    }), d.length || e(`Children with ${i} '${a}' not found.`), d;
  }
  function r(l, i) {
    return t(l, "name", i);
  }
  function s(l, i) {
    return n(l, "name", i);
  }
  return {
    seek: t,
    seekByName: r,
    seekAll: n,
    seekAllByName: s
  };
}
const Ar = (e) => {
  const t = Ke({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), n = D(/* @__PURE__ */ new Set()), r = (p) => {
    n.value.add(p);
  }, s = (p) => {
    n.value.delete(p);
  }, l = (p) => {
    Object.values(t).forEach((c) => c.delete(p)), s(p);
  }, i = (p) => {
    const { onClick: c, onPointerMove: v, onPointerEnter: f, onPointerLeave: _ } = p;
    c && t.click.set(p, c), v && t.pointerMove.set(p, v), f && t.pointerEnter.set(p, f), _ && t.pointerLeave.set(p, _);
  }, a = j(
    () => Bn(
      [
        ...Array.from(n.value),
        ...Object.values(t).map((p) => Array.from(p.keys())).flat()
      ],
      ({ uuid: p }) => p
    )
  );
  e.registerObjectAtPointerEventHandler = i, e.deregisterObjectAtPointerEventHandler = l, e.registerBlockingObjectAtPointerEventHandler = r, e.deregisterBlockingObjectAtPointerEventHandler = s;
  const { onClick: d, onPointerMove: o } = ct(a, e);
  d(({ intersects: p, event: c }) => {
    var v;
    p.length && ((v = t.click.get(p[0].object)) == null || v(p[0], c));
  });
  let h;
  return o(({ intersects: p, event: c }) => {
    var w, y, k, P;
    const v = (w = p == null ? void 0 : p[0]) == null ? void 0 : w.object, { pointerLeave: f, pointerEnter: _, pointerMove: m } = t;
    h && h !== v && ((y = f.get(h)) == null || y(h, c)), v && (h !== v && ((k = _.get(v)) == null || k(p[0], c)), (P = m.get(v)) == null || P(p[0], c)), h = v || null;
  }), {
    registerObject: i,
    deregisterObject: l,
    registerBlockingObject: r,
    deregisterBlockingObject: s
  };
};
function Ee(e) {
  let t = 0;
  return e.traverse((n) => {
    if (n.isMesh && n.geometry) {
      const r = n.geometry, s = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, l = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, i = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, d = s + l + i + a;
      t += d;
    }
  }), t;
}
function qn(e) {
  return (e / 1024).toFixed(2);
}
const ye = D({}), we = (e) => Object.assign(ye.value, e);
function Jn(e, t, n = 10) {
  const r = A(e) ? Qt() : Kt(j(() => A(t).parentElement)), s = me(Ie(r.width, n)), l = me(Ie(r.height, n)), i = j(() => s.value / l.value);
  return {
    height: l,
    width: s,
    aspectRatio: i
  };
}
function pe() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();
  let n = 0, r = !1;
  const s = () => {
    const o = Array.from(e.entries()).sort((h, p) => {
      const c = h[1].priority - p[1].priority;
      return c === 0 ? h[1].addI - p[1].addI : c;
    });
    t.clear(), o.forEach((h) => t.add(h[0]));
  }, l = (o) => {
    e.delete(o), t.delete(o);
  };
  return { on: (o, h = 0) => {
    e.set(o, { priority: h, addI: n++ });
    const p = () => l(o);
    return Xt(p), r = !0, {
      off: p
    };
  }, off: l, trigger: (...o) => {
    r && (s(), r = !1), t.forEach((h) => h(...o));
  }, dispose: () => {
    e.clear(), t.clear();
  }, get count() {
    return e.size;
  } };
}
function Qn() {
  let e = !0, t = !0, n = !1;
  const r = new Ze(!1), s = D(r.running), l = D(!1);
  let i;
  const a = Rt.generateUUID();
  let d = null;
  const o = pe(), h = pe(), p = pe();
  b();
  let c = {};
  function v(u) {
    c = u;
  }
  function f(u, M, E = 0) {
    switch (M) {
      case "before":
        return o.on(u, E);
      case "render":
        return d || (d = u), h.dispose(), h.on(u);
      case "after":
        return p.on(u, E);
    }
  }
  function _() {
    t && (t = !1, b(), C());
  }
  function m() {
    t = !0, b(), cancelAnimationFrame(i);
  }
  function w() {
    n = !1, b();
  }
  function y() {
    n = !0, b();
  }
  function k() {
    l.value = !0;
  }
  function P() {
    l.value = !1;
  }
  function C() {
    if (!e) {
      i = requestAnimationFrame(C);
      return;
    }
    const u = r.getDelta(), M = r.getElapsedTime(), E = {
      camera: V(c.camera),
      scene: V(c.scene),
      renderer: V(c.renderer),
      raycaster: V(c.raycaster),
      controls: V(c.controls),
      invalidate: c.invalidate,
      advance: c.advance
    }, T = { delta: u, elapsed: M, clock: r, ...E };
    s.value && o.trigger(T), l.value || (h.count ? h.trigger(T) : d && d(T)), s.value && p.trigger(T), i = requestAnimationFrame(C);
  }
  function b() {
    const u = !t && !n;
    r.running !== u && (r.running ? r.stop() : r.start()), s.value = r.running;
  }
  return {
    loopId: a,
    register: (u, M, E) => f(u, M, E),
    start: _,
    stop: m,
    pause: y,
    resume: w,
    pauseRender: k,
    resumeRender: P,
    isRenderPaused: l,
    isActive: s,
    setContext: v,
    setReady: (u) => e = u
  };
}
function Kn(e, t, n = 100) {
  n = n <= 0 ? 100 : n;
  const r = L(), s = /* @__PURE__ */ new Set();
  let l = !1, i = !1, a = null;
  function d() {
    a && clearTimeout(a), !i && !l && e() ? (r.trigger(t), s.forEach((c) => c()), s.clear(), l = !0) : !i && !l && (a = setTimeout(d, n));
  }
  function o() {
    i = !0, a && clearTimeout(a);
  }
  d();
  const h = (c, ...v) => {
    c(...v);
  };
  return {
    on: (c) => {
      if (l)
        return h(c, t), { off: () => {
        } };
      {
        const v = r.on(c);
        return s.add(v.off), r.on(c);
      }
    },
    off: r.off,
    trigger: r.trigger,
    cancel: o
  };
}
const X = /* @__PURE__ */ new WeakMap();
function ut(e) {
  if (e = e || ce(), X.has(e))
    return X.get(e);
  const t = 100, n = Date.now(), l = Kn(() => {
    if (Date.now() - n >= t)
      return !0;
    {
      const i = e.renderer.value, a = (i == null ? void 0 : i.domElement) || { width: 0, height: 0 };
      return !!(i && a.width > 0 && a.height > 0);
    }
  }, e);
  return X.set(e, l), l;
}
function Or(e) {
  const t = ce();
  if (t)
    return X.has(t) ? X.get(t).on(e) : ut(t).on(e);
}
function Xn({
  scene: e,
  canvas: t,
  windowSize: n,
  disableRender: r,
  rendererOptions: s,
  emit: l
}) {
  const { logWarning: i } = F(), a = $(e), d = Jn(n, t), {
    camera: o,
    cameras: h,
    registerCamera: p,
    deregisterCamera: c,
    setCameraActive: v
  } = Cn({ sizes: d, scene: e }), f = {
    mode: D(s.renderMode || "always"),
    priority: D(0),
    frames: D(0),
    maxFrames: 60,
    canBeInvalidated: j(() => f.mode.value === "on-demand" && f.frames.value === 0)
  };
  function _(R = 1) {
    s.renderMode === "on-demand" ? f.frames.value = Math.min(f.maxFrames, f.frames.value + R) : i("`invalidate` can only be used when `renderMode` is set to `on-demand`");
  }
  function m() {
    s.renderMode === "manual" ? f.frames.value = 1 : i("`advance` can only be used when `renderMode` is set to `manual`");
  }
  const { renderer: w } = zn(
    {
      scene: e,
      canvas: t,
      options: s,
      emit: l,
      // TODO: replace contextParts with full ctx at https://github.com/Tresjs/tres/issues/516
      contextParts: { sizes: d, camera: o, render: f, invalidate: _, advance: m },
      disableRender: r
    }
  ), y = {
    sizes: d,
    scene: a,
    camera: o,
    cameras: me(h),
    renderer: w,
    raycaster: $(new Dt()),
    controls: D(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    render: f,
    advance: m,
    extend: we,
    invalidate: _,
    registerCamera: p,
    setCameraActive: v,
    deregisterCamera: c,
    loop: Qn()
  };
  ge("useTres", y), y.scene.value.__tres = {
    root: y
  }, y.loop.register(() => {
    o.value && f.frames.value > 0 && (w.value.render(e, o.value), l("render", y.renderer.value)), f.priority.value = 0, f.mode.value === "always" ? f.frames.value = 1 : f.frames.value = Math.max(0, f.frames.value - 1);
  }, "render");
  const { on: k, cancel: P } = ut(y);
  y.loop.setReady(!1), y.loop.start(), k(() => {
    l("ready", y), y.loop.setReady(!0);
  }), Y(() => {
    P(), y.loop.stop();
  });
  const C = 100, b = Zt({ every: C }), { isSupported: u, memory: M } = en({ interval: C }), E = 160;
  let T = performance.now();
  const I = ({ timestamp: R }) => {
    y.scene.value && (y.perf.memory.allocatedMem = Ee(y.scene.value)), R - T >= C && (T = R, y.perf.fps.accumulator.push(b.value), y.perf.fps.accumulator.length > E && y.perf.fps.accumulator.shift(), y.perf.fps.value = b.value, u.value && M.value && (y.perf.memory.accumulator.push(M.value.usedJSHeapSize / 1024 / 1024), y.perf.memory.accumulator.length > E && y.perf.memory.accumulator.shift(), y.perf.memory.currentMem = y.perf.memory.accumulator.reduce((G, ee) => G + ee, 0) / y.perf.memory.accumulator.length));
  };
  let O = 0;
  const x = 1, { pause: N } = rt(({ delta: R }) => {
    window.__TRES__DEVTOOLS__ && (I({ timestamp: performance.now() }), O += R, O >= x && (window.__TRES__DEVTOOLS__.cb(y), O = 0));
  }, { immediate: !0 });
  return Y(() => {
    N();
  }), y;
}
function ce() {
  const e = vt("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const xr = ce;
function Lr() {
  const {
    camera: e,
    scene: t,
    renderer: n,
    loop: r,
    raycaster: s,
    controls: l,
    invalidate: i,
    advance: a
  } = ce();
  r.setContext({
    camera: e,
    scene: t,
    renderer: n,
    raycaster: s,
    controls: l,
    invalidate: i,
    advance: a
  });
  function d(p, c = 0) {
    return r.register(p, "before", c);
  }
  function o(p) {
    return r.register(p, "render");
  }
  function h(p, c = 0) {
    return r.register(p, "after", c);
  }
  return {
    pause: r.pause,
    resume: r.resume,
    pauseRender: r.pauseRender,
    resumeRender: r.resumeRender,
    isActive: r.isActive,
    onBeforeRender: d,
    render: o,
    onAfterRender: h
  };
}
function Zn(e, t, n) {
  const r = $(), s = $();
  e && (r.value = e), t && (s.value = t);
  const l = (u) => {
    var M;
    return ((M = u.__tres) == null ? void 0 : M.eventCount) > 0;
  }, i = (u) => {
    var M;
    return ((M = u.children) == null ? void 0 : M.some((E) => i(E))) || l(u);
  }, a = j(() => {
    var u, M;
    return ((M = (u = r.value) == null ? void 0 : u.children) == null ? void 0 : M.filter(i)) || [];
  });
  function d(u, M) {
    if (Array.isArray(u))
      for (const E of u)
        E(M);
    typeof u == "function" && u(M);
  }
  function o(u, M) {
    const E = [], T = () => M.stopPropagating = !0;
    M.stopPropagation = T;
    for (const I of M == null ? void 0 : M.intersections) {
      if (M.stopPropagating)
        return;
      M = { ...M, ...I };
      const { object: O } = I;
      M.eventObject = O, d(O[u], M), E.push(O);
      let x = O.parent;
      for (; x !== null && !M.stopPropagating && !E.includes(x); )
        M.eventObject = x, d(x[u], M), E.push(x), x = x.parent;
      const N = Rn(u.slice(2));
      n(N, { intersection: I, event: M });
    }
  }
  const {
    onClick: h,
    onDblClick: p,
    onContextMenu: c,
    onPointerMove: v,
    onPointerDown: f,
    onPointerUp: _,
    onPointerMissed: m,
    onWheel: w,
    forceUpdate: y
  } = ct(a, t);
  _((u) => o("onPointerUp", u)), f((u) => o("onPointerDown", u)), h((u) => o("onClick", u)), p((u) => o("onDoubleClick", u)), c((u) => o("onContextMenu", u)), w((u) => o("onWheel", u));
  let k = [];
  v((u) => {
    const M = u.intersections.map(({ object: T }) => T), E = u.intersections;
    k.forEach(({ object: T }) => {
      M.includes(T) || (u.intersections = k, o("onPointerLeave", u), o("onPointerOut", u));
    }), u.intersections = E, u.intersections.forEach(({ object: T }) => {
      k.includes(T) || (o("onPointerEnter", u), o("onPointerOver", u));
    }), o("onPointerMove", u), k = u.intersections;
  });
  const P = [];
  m((u) => {
    const M = () => u.stopPropagating = !0;
    u.stopPropagation = M, P.forEach((E) => {
      u.stopPropagating || (u.eventObject = E, d(E.onPointerMissed, u));
    }), n("pointer-missed", { event: u });
  });
  function C(u) {
    Ue(u) && W(u) && u.onPointerMissed && P.push(u);
  }
  function b(u) {
    if (Ue(u) && W(u)) {
      const M = P.indexOf(u);
      M > -1 && P.splice(M, 1);
    }
  }
  return t.eventManager = {
    forceUpdate: y,
    registerPointerMissedObject: C,
    deregisterPointerMissedObject: b
  }, { forceUpdate: y, registerPointerMissedObject: C, deregisterPointerMissedObject: b };
}
function ze(e, t, n) {
  const r = e;
  return r.__tres = {
    type: "unknown",
    eventCount: 0,
    root: n,
    handlers: {},
    memoizedProps: {},
    objects: [],
    parent: null,
    ...t
  }, r;
}
function Ve(e) {
  var n;
  const t = (n = e == null ? void 0 : e.__tres) == null ? void 0 : n.root;
  t && t.render && t.render.canBeInvalidated.value && t.invalidate();
}
const { logError: Ye } = F(), qe = [
  "onClick",
  "onContextMenu",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut",
  "onDoubleClick",
  "onPointerDown",
  "onPointerUp",
  "onPointerCancel",
  "onPointerMissed",
  "onLostPointerCapture",
  "onWheel"
], er = (e) => {
  const t = e.scene.value;
  function n(o, h, p, c) {
    if (c || (c = {}), c.args || (c.args = []), o === "template" || xn(o))
      return null;
    let v = o.replace("Tres", ""), f;
    if (o === "primitive") {
      (c == null ? void 0 : c.object) === void 0 && Ye("Tres primitives need a prop 'object'");
      const _ = c.object;
      v = _.type, f = Object.assign(_.clone(), { type: v });
    } else {
      const _ = ye.value[v];
      _ || Ye(
        `${v} is not defined on the THREE namespace. Use extend to add it to the catalog.`
      ), f = new _(...c.args);
    }
    return f ? (f.isCamera && (c != null && c.position || f.position.set(3, 3, 3), c != null && c.lookAt || f.lookAt(0, 0, 0)), (c == null ? void 0 : c.attach) === void 0 && (f.isMaterial ? f.attach = "material" : f.isBufferGeometry && (f.attach = "geometry")), f = ze(f, {
      ...f.__tres,
      type: v,
      memoizedProps: c,
      eventCount: 0,
      disposable: !0,
      primitive: o === "primitive"
    }, e), f.isObject3D && f.__tres && (c != null && c.material || c != null && c.geometry) && (f.__tres.disposable = !1), f) : null;
  }
  function r(o, h) {
    var f, _;
    if (!o)
      return;
    const p = o.__tres ? o : ze(o, {}), c = h || t;
    e.registerCamera(o), (f = e.eventManager) == null || f.registerPointerMissedObject(o);
    let v = !1;
    W(o) && W(c) ? (c.add(o), v = !0, o.dispatchEvent({ type: "added" })) : ot(o) ? c.fog = o : typeof o.attach == "string" && (o.__previousAttach = o[c == null ? void 0 : c.attach], c && (c[o.attach] = o)), p.__tres.parent = c, (_ = c.__tres) != null && _.objects && !v && (c.__tres.objects.includes(o) || c.__tres.objects.push(o));
  }
  function s(o) {
    var p, c, v, f, _;
    if (!o)
      return;
    o.parent = o.parent || t;
    const h = ((p = o.__tres) == null ? void 0 : p.parent) || t;
    o.__tres && (o.__tres.parent = null), h.__tres && "objects" in h.__tres && Nn(h.__tres.objects, (m) => m !== o), W(o) && ((c = o.removeFromParent) == null || c.call(o), o.traverse((w) => {
      var y;
      e.deregisterCamera(w), (y = e.eventManager) == null || y.deregisterPointerMissedObject(w);
    }), e.deregisterCamera(o), Ve(o), !((v = o.__tres) != null && v.primitive) && ((f = o.__tres) != null && f.disposable) && Ce(o), (_ = o.dispose) == null || _.call(o));
  }
  function l(o, h, p, c) {
    var y, k;
    if (!o)
      return;
    let v = o, f = h;
    if ((y = o.__tres) != null && y.primitive && f === "object" && p !== null) {
      const P = n("primitive", void 0, void 0, {
        object: c
      });
      for (const C in P) {
        if (C === "uuid")
          continue;
        const b = o[C], u = P[C];
        !(b != null && b.set) && !Q(b) ? o[C] = u : b.constructor === u.constructor && (b != null && b.copy) ? b == null || b.copy(u) : Array.isArray(u) ? b.set(...u) : !b.isColor && b.setScalar ? b.setScalar(u) : b.set(u);
      }
      P != null && P.__tres && (P.__tres.root = e), P != null && P.isGroup ? (o.geometry = void 0, o.material = void 0) : delete o.isGroup;
    }
    if (W(o) && f === "blocks-pointer-events") {
      c || c === "" ? o[f] = c : delete o[f];
      return;
    }
    qe.includes(h) && (o.__tres.eventCount += 1);
    let _ = re(f), m = v == null ? void 0 : v[_];
    if (f === "args") {
      const P = o, C = p ?? [], b = c ?? [], u = ((k = o.__tres) == null ? void 0 : k.type) || o.type;
      u && C.length && !In(C, b) && (v = Object.assign(
        P,
        new ye.value[u](...c)
      ));
      return;
    }
    if (v.type === "BufferGeometry") {
      if (f === "args")
        return;
      v.setAttribute(
        re(f),
        new Bt(...c)
      );
      return;
    }
    if (f.includes("-") && m === void 0) {
      const P = f.split("-");
      m = P.reduce((C, b) => C[re(b)], v), f = P.pop(), _ = f, m != null && m.set || (v = P.reduce((C, b) => C[re(b)], v));
    }
    let w = c;
    if (w === "" && (w = !0), Q(m)) {
      qe.includes(h) || (ve(w) ? o[_](...w) : o[_](w)), _.startsWith("on") && Q(w) && (v[_] = w);
      return;
    }
    !(m != null && m.set) && !Q(m) ? v[_] = w : m.constructor === w.constructor && (m != null && m.copy) ? m == null || m.copy(w) : ve(w) ? m.set(...w) : !m.isColor && m.setScalar ? m.setScalar(w) : m.set(w), Ve(o);
  }
  function i(o) {
    return (o == null ? void 0 : o.parent) || null;
  }
  function a(o) {
    const h = new jt();
    return h.name = o, h.__tres = { type: "Comment" }, h.__tres.root = t == null ? void 0 : t.__tres.root, h;
  }
  function d(o) {
    if (!o)
      return null;
    const h = o.parent || t, p = h.children.indexOf(o);
    return h.children[p + 1] || null;
  }
  return {
    insert: r,
    remove: s,
    createElement: n,
    patchProp: l,
    parentNode: i,
    createText: () => void 0,
    createComment: a,
    setText: () => void 0,
    setElementText: () => void 0,
    nextSibling: d,
    querySelector: () => void 0,
    setScopeId: () => void 0,
    cloneNode: () => void 0,
    insertStaticContent: () => void 0
  };
};
function tr() {
  return ft().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function ft() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const nr = typeof Proxy == "function", rr = "devtools-plugin:setup", or = "plugin:settings:set";
let z, be;
function ir() {
  var e;
  return z !== void 0 || (typeof window < "u" && window.performance ? (z = !0, be = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (z = !0, be = globalThis.perf_hooks.performance) : z = !1), z;
}
function sr() {
  return ir() ? be.now() : Date.now();
}
class ar {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const r = {};
    if (t.settings)
      for (const i in t.settings) {
        const a = t.settings[i];
        r[i] = a.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${t.id}`;
    let l = Object.assign({}, r);
    try {
      const i = localStorage.getItem(s), a = JSON.parse(i);
      Object.assign(l, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return l;
      },
      setSettings(i) {
        try {
          localStorage.setItem(s, JSON.stringify(i));
        } catch {
        }
        l = i;
      },
      now() {
        return sr();
      }
    }, n && n.on(or, (i, a) => {
      i === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (i, a) => this.target ? this.target.on[a] : (...d) => {
        this.onQueue.push({
          method: a,
          args: d
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (i, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...d) => (this.targetQueue.push({
        method: a,
        args: d,
        resolve: () => {
        }
      }), this.fallbacks[a](...d)) : (...d) => new Promise((o) => {
        this.targetQueue.push({
          method: a,
          args: d,
          resolve: o
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function lr(e, t) {
  const n = e, r = ft(), s = tr(), l = nr && n.enableEarlyProxy;
  if (s && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !l))
    s.emit(rr, e, t);
  else {
    const i = l ? new ar(n, s) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: i
    }), i && t(i.proxiedTarget);
  }
}
function cr(e, t) {
  const n = `▲ ■ ●${e}`;
  typeof Je == "function" ? Je(n, t) : console.log(n);
}
function Je(e, t) {
  throw new Error(e + t);
}
const dt = (e) => {
  const t = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && t.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const n = Ee(e);
  return n > 0 && t.tags.push({
    label: `${qn(n)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (t.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), t.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (t.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), t.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), t;
};
function pt(e, t, n = "") {
  e.children.forEach((r) => {
    if (r.type === "HightlightMesh" || n && !r.type.includes(n) && !r.name.includes(n))
      return;
    const s = dt(r);
    t.children.push(s), pt(r, s, n);
  });
}
const ur = [], q = "tres:inspector", fr = Ke({
  sceneGraph: null
});
function dr(e, t) {
  lr(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: ur,
      app: e
    },
    (n) => {
      typeof n.now != "function" && cr(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), n.addInspector({
        id: q,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        n.sendInspectorTree(q);
      }, 1e3), setInterval(() => {
        n.notifyComponentUpdate();
      }, 5e3), n.on.getInspectorTree((l) => {
        if (l.inspectorId === q) {
          const i = dt(t.scene.value);
          pt(t.scene.value, i, l.filter), fr.sceneGraph = i, l.rootNodes = [i];
        }
      });
      let r = null, s = null;
      n.on.getInspectorState((l) => {
        var i;
        if (l.inspectorId === q) {
          const [a] = t.scene.value.getObjectsByProperty("uuid", l.nodeId);
          if (!a)
            return;
          if (s && r && r.parent && s.remove(r), a.isMesh) {
            const d = $n(a);
            a.add(d), r = d, s = a;
          }
          l.state = {
            object: [
              {
                key: "uuid",
                editable: !0,
                value: a.uuid
              },
              {
                key: "name",
                editable: !0,
                value: a.name
              },
              {
                key: "type",
                editable: !0,
                value: a.type
              },
              {
                key: "position",
                editable: !0,
                value: a.position
              },
              {
                key: "rotation",
                editable: !0,
                value: a.rotation
              },
              {
                key: "scale",
                editable: !0,
                value: a.scale
              },
              {
                key: "geometry",
                value: a.geometry
              },
              {
                key: "material",
                value: a.material
              },
              {
                key: "color",
                editable: !0,
                value: a.color
              },
              {
                key: "intensity",
                editable: !0,
                value: a.intensity
              },
              {
                key: "castShadow",
                editable: !0,
                value: a.castShadow
              },
              {
                key: "receiveShadow",
                editable: !0,
                value: a.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: !0,
                value: a.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: !0,
                value: a.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: !0,
                value: a.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: a.matrixWorld
              },
              {
                key: "visible",
                editable: !0,
                value: a.visible
              }
            ]
          }, a.isScene && (l.state.info = {
            memory: Ee(a),
            objects: a.children.length,
            calls: t.renderer.value.info.render.calls,
            triangles: t.renderer.value.info.render.triangles,
            points: t.renderer.value.info.render.points,
            lines: t.renderer.value.info.render.lines
          }, l.state.programs = ((i = t.renderer.value.info.programs) == null ? void 0 : i.map((d) => ({
            key: d.name,
            value: {
              ...d,
              vertexShader: d.vertexShader,
              attributes: d.getAttributes(),
              uniforms: d.getUniforms()
            }
          }))) || []);
        }
      }), n.on.editInspectorState((l) => {
        l.inspectorId === q && Un(t.scene.value, l.nodeId, l.path, l.state.value);
      });
    }
  );
}
const pr = ["data-scene", "data-tres"], mr = /* @__PURE__ */ Le({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    renderMode: { default: "always" },
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  emits: [
    "render",
    "click",
    "double-click",
    "context-menu",
    "pointer-move",
    "pointer-up",
    "pointer-down",
    "pointer-enter",
    "pointer-leave",
    "pointer-over",
    "pointer-out",
    "pointer-missed",
    "wheel",
    "ready"
  ],
  setup(e, { expose: t, emit: n }) {
    var _;
    const r = e, s = n, l = yt(), { logWarning: i } = F(), a = D(), d = $(new et()), o = (_ = Re()) == null ? void 0 : _.appContext.app;
    we(Xe);
    const h = (m) => Le({
      setup() {
        var y;
        const w = (y = Re()) == null ? void 0 : y.appContext;
        return w && (w.app = o), ge("useTres", m), ge("extend", we), typeof window < "u" && dr(w == null ? void 0 : w.app, m), () => De(Et, null, l != null && l.default ? l.default() : []);
      }
    }), p = (m) => {
      const w = h(m), { render: y } = Ct(er(m));
      y(De(w), d.value);
    }, c = (m, w = !1) => {
      Ce(m.scene.value), w && (m.renderer.value.dispose(), m.renderer.value.renderLists.dispose(), m.renderer.value.forceContextLoss()), d.value.__tres = {
        root: m
      }, p(m);
    }, v = j(() => r.disableRender), f = $(null);
    return t({ context: f, dispose: () => c(f.value, !0) }), wt(() => {
      const m = a;
      f.value = Xn({
        scene: d.value,
        canvas: m,
        windowSize: r.windowSize ?? !1,
        disableRender: v.value ?? !1,
        rendererOptions: r,
        emit: s
      }), Zn(d.value, f.value, s);
      const { registerCamera: w, camera: y, cameras: k, deregisterCamera: P } = f.value;
      p(f.value);
      const C = () => {
        const b = new he(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        b.position.set(3, 3, 3), b.lookAt(0, 0, 0), w(b);
        const u = Me(() => {
          k.value.length >= 2 && (b.removeFromParent(), P(b), u == null || u());
        });
      };
      J(
        () => r.camera,
        (b, u) => {
          b && w(b), u && (u.removeFromParent(), P(u));
        },
        {
          immediate: !0
        }
      ), y.value || (i(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), C());
    }), Y(() => {
      c(f.value);
    }), (m, w) => (bt(), Mt("canvas", {
      ref_key: "canvas",
      ref: a,
      "data-scene": d.value.uuid,
      class: _t(m.$attrs.class),
      "data-tres": `tresjs ${V(Mn).version}`,
      style: Pt({
        display: "block",
        width: "100%",
        height: "100%",
        position: m.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...m.$attrs.style
      })
    }, null, 14, pr));
  }
}), gr = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], hr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !gr.includes(e) || e === "primitive"
    }
  }
}, Rr = hr, Dr = {
  mounted: (e, t) => {
    if (t.arg) {
      console.log(`v-log:${t.arg}`, e[t.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
class mt extends It {
  constructor(t, n) {
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new Be();
    s.setAttribute("position", new je(r, 3)), s.computeBoundingSphere();
    const l = new Ht({ fog: !1 });
    super(s, l), this.light = t, this.color = n, this.type = "RectAreaLightHelper";
    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new Be();
    a.setAttribute("position", new je(i, 3)), a.computeBoundingSphere(), this.add(new Ut(a, new tt({ side: $t, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const t = this.material.color, n = Math.max(t.r, t.g, t.b);
      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const { logWarning: Qe } = F();
let ie, U;
const vr = {
  DirectionalLight: Ft,
  PointLight: Wt,
  SpotLight: Nt,
  HemisphereLight: Gt,
  RectAreaLight: mt
}, Br = {
  mounted: (e) => {
    if (!e.isLight) {
      Qe(`${e.type} is not a light`);
      return;
    }
    ie = vr[e.type], e.parent.add(new ie(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    U = e.parent.children.find((t) => t instanceof ie), !(U instanceof mt) && U.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      Qe(`${e.type} is not a light`);
      return;
    }
    U = e.parent.children.find((t) => t instanceof ie), U && U.dispose && U.dispose(), e.parent.remove(U);
  }
}, { logWarning: yr } = F();
let B = null;
const jr = {
  updated: (e, t) => {
    var s;
    const n = Fn(t);
    if (!n) {
      yr(`v-distance-to: problem with binding value: ${t.value}`);
      return;
    }
    B && (B.dispose(), e.parent.remove(B));
    const r = n.clone().sub(e.position);
    r.normalize(), B = new zt(r, e.position, e.position.distanceTo(n), 16776960), e.parent.add(B), console.table(
      [
        ["Distance:", e.position.distanceTo(n)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${n.x}, y:${n.y}, z:${n == null ? void 0 : n.z}`]
      ]
    );
  },
  unmounted: (e) => {
    B == null || B.dispose(), e.parent.remove(B);
  }
}, Ir = {
  install(e) {
    e.component("TresCanvas", mr);
  }
};
export {
  mr as TresCanvas,
  ye as catalogue,
  Qn as createRenderLoop,
  Ir as default,
  Ce as dispose,
  we as extend,
  Cr as isProd,
  Tn as normalizeColor,
  Er as normalizeVectorFlexibleParam,
  Or as onTresReady,
  Rr as templateCompilerOptions,
  Yn as trasverseObjects,
  Cn as useCamera,
  kr as useLoader,
  F as useLogger,
  Lr as useLoop,
  Ar as usePointerEventHandler,
  ct as useRaycaster,
  Pr as useRenderLoop,
  zn as useRenderer,
  Tr as useSeek,
  Sr as useTexture,
  xr as useTres,
  ce as useTresContext,
  Xn as useTresContextProvider,
  Zn as useTresEventManager,
  jr as vDistanceTo,
  Br as vLightHelper,
  Dr as vLog
};
