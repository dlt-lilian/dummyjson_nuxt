import { defineNuxtModule, createResolver, addPlugin, addImportsDir, addServerImportsDir } from '@nuxt/kit';
import { fileURLToPath } from 'url';
import defu from 'defu';
import { execa } from 'execa';
import chalk from 'chalk';
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'pathe';
import { addDevDependency, addDependency } from 'nypm';
import prompts from 'prompts';

function logSuccess(message) {
  console.log(chalk.green(`\u2714 ${message}`));
}
function logError(message) {
  console.error(chalk.red(`\u2718 ${message}`));
}
function log(message) {
  console.log(message);
}
const PREDEFINED_LOG_MESSAGES = {
  isPrismaCLIinstalled: {
    yes: `Prisma CLI is already installed.`,
    no: `Prisma CLI is not installed.`
  },
  installPrismaCLI: {
    action: "Installing Prisma CLI...",
    yes: `Successfully installed "Prisma CLI.`,
    no: `Failed to install Prisma CLI.`
  },
  checkIfPrismaSchemaExists: {
    yes: "Prisma schema file exists.",
    no: "Prisma schema file does not exist."
  },
  initPrisma: {
    action: "Initializing Prisma project...\n",
    error: "Failed to initialize Prisma project."
  },
  checkIfMigrationsFolderExists: {
    success: "Database migrations folder exists.",
    error: "Database migrations folder does not exist."
  },
  writeToSchema: {
    errorReadingFile: "Error reading existing schema file.",
    failedToWrite: "Failed to write models to Prisma schema."
  },
  runMigration: {
    action: "Migrating database schema...\n",
    success: "Created User and Post tables in the database.",
    error: "Failed to run Prisma migration."
  },
  formatSchema: {
    action: "Formatting Prisma schema...\n",
    success: "Successfully formatted Prisma schema.",
    error: "Failed to format Prisma schema file."
  },
  generatePrismaClient: {
    action: "Generating Prisma client...\n",
    prismaClientInstallationError: "Failed to install Prisma Client.\n",
    success: "Prisma Client successfully generated!",
    error: "Failed to generate Prisma Client.\n"
  },
  installStudio: {
    action: "Starting Prisma Studio...\n",
    success: `Prisma Studio installed.` + chalk.white(
      `
After clicking ${chalk.bold("Get Started")} in Nuxt DevTools, click on the ${chalk.bold("three dots (\uFE19)")} in the lower left-hand side to reveal additional tabs.
Locate the Prisma logo to open Prisma Studio.`
    ),
    error: "Failed to install Prisma Studio."
  },
  writeClientInLib: {
    found: "Skipping the creation of a lib/prisma.ts file that would hold a global instance of the Prisma Client because the prisma.ts file already exists in the lib folder.",
    success: "Global instance of Prisma Client created in lib/prisma.ts."
  },
  PRISMA_SETUP_SKIPPED_WARNING: chalk.yellow(
    `${chalk.bold("Warning")}: Nuxt Prisma Module setup skipped.
This may cause unexpected behavior.`
  ),
  skipMigrations: `
Not migrating the database.`,
  skipInstallingPrismaStudio: "Skipped installing Prisma Studio.",
  suggestions: {
    migrate: chalk.yellow(chalk.bold("\nHint: ")) + `You can manually run migrations by executing ${chalk.cyan.bold("npx prisma migrate dev")} or visit the ${chalk.blue.bold("Prisma Migrate")} docs for more info:
${chalk.underline.blue("https://pris.ly/nuxt/migrate")}. Or if you have pre-existing data on your database, you have to introspect it. Learn more in our docs:
${chalk.underline.blue("https://pris.ly/nuxt/dbpull")}.
`
  }
};

async function isPrismaCLIInstalled(directory) {
  try {
    await execa("npx", ["prisma", "version"], { cwd: directory });
    logSuccess(PREDEFINED_LOG_MESSAGES.isPrismaCLIinstalled.yes);
    return true;
  } catch (error) {
    logError(PREDEFINED_LOG_MESSAGES.isPrismaCLIinstalled.no);
    return false;
  }
}
async function installPrismaCLI(directory) {
  try {
    await addDevDependency("prisma", {
      cwd: directory
    });
    logSuccess(PREDEFINED_LOG_MESSAGES.installPrismaCLI.yes);
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.installPrismaCLI.no);
    log(err);
  }
}
function checkIfPrismaSchemaExists(paths) {
  const exists = paths.reduce((prev, current) => {
    return existsSync(current) || prev;
  }, false);
  if (exists) {
    logSuccess(PREDEFINED_LOG_MESSAGES.checkIfPrismaSchemaExists.yes);
    return true;
  }
  logError(PREDEFINED_LOG_MESSAGES.checkIfPrismaSchemaExists.no);
  return false;
}
function moveEnvFileContent(dirA, dirB) {
  if (dirA === dirB) {
    return;
  }
  const envFileA = join(dirA, ".env");
  const envFileB = join(dirB, ".env");
  try {
    if (!existsSync(envFileB)) {
      console.error(`Source .env file does not exist in directory: ${dirB}`);
      return;
    }
    const envContentB = readFileSync(envFileB, "utf8");
    if (existsSync(envFileA)) {
      const envContentA = readFileSync(envFileA, "utf8");
      const combinedContent = `${envContentA}
${envContentB}`;
      writeFileSync(envFileA, combinedContent, "utf8");
    } else {
      writeFileSync(envFileA, envContentB, "utf8");
    }
    console.log(`Successfully moved content from ${envFileB} to ${envFileA}`);
  } catch (error) {
    console.error(`Failed to move .env file content: ${error}`);
  }
}
async function initPrisma({
  directory,
  rootDir,
  provider = "sqlite",
  datasourceUrl
}) {
  const commandArgs = ["prisma", "init", "--datasource-provider"];
  commandArgs.push(provider);
  if (datasourceUrl) {
    commandArgs.push("--url");
    commandArgs.push(datasourceUrl);
  }
  try {
    log(PREDEFINED_LOG_MESSAGES.initPrisma.action);
    const { stdout: initializePrisma } = await execa("npx", commandArgs, {
      cwd: directory
    });
    log(initializePrisma?.split("Next steps")?.[0]);
    try {
      moveEnvFileContent(directory, rootDir);
    } catch (error) {
      console.log();
    }
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.initPrisma.error);
    log(err);
    return false;
  }
}
function checkIfMigrationsFolderExists(path) {
  if (existsSync(path)) {
    logSuccess(PREDEFINED_LOG_MESSAGES.checkIfMigrationsFolderExists.success);
    return true;
  }
  logError(PREDEFINED_LOG_MESSAGES.checkIfMigrationsFolderExists.error);
  return false;
}
async function writeToSchema(prismaSchemaPath) {
  try {
    let existingSchema = "";
    try {
      existingSchema = readFileSync(prismaSchemaPath, "utf-8");
    } catch {
      logError(PREDEFINED_LOG_MESSAGES.writeToSchema.errorReadingFile);
      return false;
    }
    const addModel = `model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}
`;
    if (existingSchema.trim().includes(addModel.trim()))
      return;
    const updatedSchema = `${existingSchema.trim()}

${addModel}`;
    writeFileSync(prismaSchemaPath, updatedSchema);
  } catch {
    logError(PREDEFINED_LOG_MESSAGES.writeToSchema.failedToWrite);
  }
}
async function runMigration(directory, schemaPath) {
  try {
    log(PREDEFINED_LOG_MESSAGES.runMigration.action);
    await execa(
      "npx",
      ["prisma", "migrate", "dev", "--name", "init"].concat(schemaPath),
      {
        cwd: directory
      }
    );
    logSuccess(PREDEFINED_LOG_MESSAGES.runMigration.success);
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.runMigration.error);
    log(err);
    log(PREDEFINED_LOG_MESSAGES.suggestions.migrate);
    return false;
  }
}
async function formatSchema(directory, schemaPath) {
  try {
    log(PREDEFINED_LOG_MESSAGES.formatSchema.action);
    await execa("npx", ["prisma", "format"].concat(schemaPath), {
      cwd: directory
    });
  } catch {
    logError(PREDEFINED_LOG_MESSAGES.formatSchema.error);
  }
}
async function installPrismaClient(directory, installPrismaClient2 = true) {
  log(PREDEFINED_LOG_MESSAGES.generatePrismaClient.action);
  if (installPrismaClient2) {
    try {
      await addDependency("@prisma/client", {
        cwd: directory
      });
    } catch (error) {
      logError(
        PREDEFINED_LOG_MESSAGES.generatePrismaClient.prismaClientInstallationError
      );
    }
  }
}
async function generatePrismaClient(directory, prismaSchemaPath, verboseLog = false) {
  try {
    const { stdout: generateClient } = await execa(
      "npx",
      ["prisma", "generate"].concat(prismaSchemaPath),
      { cwd: directory }
    );
    log("\n" + generateClient.split("\n").slice(0, 4).join("\n") + "\n");
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.generatePrismaClient.error);
    if (verboseLog) {
      log(err);
    }
  }
}
async function installStudio(directory, schemaLocation) {
  try {
    log(PREDEFINED_LOG_MESSAGES.installStudio.action);
    const subprocess = execa(
      "npx",
      ["prisma", "studio", "--browser", "none"].concat(schemaLocation),
      {
        cwd: directory
      }
    );
    subprocess.unref();
    logSuccess(PREDEFINED_LOG_MESSAGES.installStudio.success);
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.installStudio.error);
    log(err);
    return false;
  }
}
async function writeClientInLib(path) {
  const existingContent = existsSync(`${path}/lib/prisma.ts`);
  try {
    if (!existingContent) {
      const prismaClient = `import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare const globalThis: {
  prismaGlobal: ReturnType<typeof prismaClientSingleton>;
} & typeof global;

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma
`;
      if (!existsSync(`${path}/lib`)) {
        mkdirSync(`${path}/lib`);
      }
      if (existsSync(`${path}/lib/prisma.ts`)) {
        log(PREDEFINED_LOG_MESSAGES.writeClientInLib.found);
        return;
      }
      writeFileSync(`${path}/lib/prisma.ts`, prismaClient);
      logSuccess(PREDEFINED_LOG_MESSAGES.writeClientInLib.success);
    }
  } catch (e) {
    log(e);
  }
}

async function executeRequiredPrompts({
  promptForMigrate = true,
  promptForPrismaStudio = true
}) {
  const options = [];
  if (promptForMigrate) {
    options.push({
      type: "confirm",
      name: "promptForPrismaMigrate" /* PROMPT_MIGRATE */,
      message: "Do you want to migrate database changes to your database?",
      initial: true
    });
  }
  if (promptForPrismaStudio) {
    options.push({
      type: "confirm",
      name: "promptForInstallingStudio" /* PROMPT_STUDIO */,
      message: "Do you want to view and edit your data by installing Prisma Studio in Nuxt DevTools?",
      initial: true
    });
  }
  if (options.length === 0) {
    return null;
  }
  try {
    const answers = await prompts(options);
    const result = {
      ["promptForPrismaMigrate" /* PROMPT_MIGRATE */]: answers["promptForPrismaMigrate" /* PROMPT_MIGRATE */] ?? false,
      ["promptForInstallingStudio" /* PROMPT_STUDIO */]: answers["promptForInstallingStudio" /* PROMPT_STUDIO */] ?? false
    };
    return result;
  } catch (error) {
    console.error("Error during prompts execution:", error);
    return null;
  }
}

const module = defineNuxtModule({
  meta: {
    name: "@prisma/nuxt",
    configKey: "prisma"
  },
  // Default configuration options for the module
  defaults: {
    datasources: {
      db: {
        url: process.env.DATABASE_URL
        // Security: Ensure DATABASE_URL is correctly set and secure
      }
    },
    log: [],
    errorFormat: "pretty",
    writeToSchema: true,
    formatSchema: true,
    runMigration: true,
    installClient: true,
    installCLI: true,
    generateClient: true,
    installStudio: true,
    autoSetupPrisma: false,
    skipPrompts: false,
    prismaRoot: void 0,
    prismaSchemaPath: void 0
  },
  async setup(options, nuxt) {
    const { resolve: resolveProject } = createResolver(nuxt.options.rootDir);
    const { resolve: resolver } = createResolver(import.meta.url);
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    const npmLifecycleEvent = process.env?.npm_lifecycle_event;
    const skipAllPrompts = options.skipPrompts || npmLifecycleEvent === "dev:build";
    const PRISMA_SCHEMA_CMD = options.prismaSchemaPath ? ["--schema", options.prismaSchemaPath] : [];
    const prepareModule = () => {
      nuxt.options.experimental.componentIslands ||= {};
      nuxt.options.experimental.componentIslands = true;
      addPlugin(resolver("./runtime/plugin"));
      addImportsDir(resolver(runtimeDir, "composables"));
      addServerImportsDir(resolver(runtimeDir, "utils"));
      nuxt.options.vite.optimizeDeps = defu(
        nuxt.options.vite.optimizeDeps || {},
        {
          include: ["@prisma/nuxt > @prisma/client"]
        }
      );
    };
    const forceSkipPrismaSetup = import.meta.env?.SKIP_PRISMA_SETUP ?? process.env?.SKIP_PRISMA_SETUP ?? false;
    nuxt.options.runtimeConfig.public.prisma = defu(
      nuxt.options.runtimeConfig.public.prisma || {},
      {
        log: options.log,
        errorFormat: options.errorFormat
      }
    );
    if (forceSkipPrismaSetup || npmLifecycleEvent === "postinstall") {
      if (npmLifecycleEvent !== "postinstall") {
        log(PREDEFINED_LOG_MESSAGES.PRISMA_SETUP_SKIPPED_WARNING);
      }
      prepareModule();
      return;
    }
    const PROJECT_PATH = resolveProject();
    const LAYER_PATH = options.prismaRoot ? resolveProject(options.prismaRoot) : PROJECT_PATH;
    if (options.installCLI) {
      const prismaInstalled = await isPrismaCLIInstalled(PROJECT_PATH);
      if (!prismaInstalled) {
        await installPrismaCLI(PROJECT_PATH);
        await generatePrismaClient(
          PROJECT_PATH,
          PRISMA_SCHEMA_CMD,
          options.log?.includes("error")
        );
      }
    }
    const prismaSchemaExists = checkIfPrismaSchemaExists([
      resolveProject(LAYER_PATH, "prisma", "schema.prisma"),
      resolveProject(LAYER_PATH, "prisma", "schema")
    ]);
    const prismaMigrateWorkflow = async () => {
      const migrationFolderExists = checkIfMigrationsFolderExists(
        resolveProject(LAYER_PATH, "prisma", "migrations")
      );
      if (migrationFolderExists || !options.runMigration) {
        log(PREDEFINED_LOG_MESSAGES.skipMigrations);
        return;
      }
      const migrateAndFormatSchema = async () => {
        await runMigration(PROJECT_PATH, PRISMA_SCHEMA_CMD);
        if (options.formatSchema) {
          await formatSchema(PROJECT_PATH, PRISMA_SCHEMA_CMD);
        }
      };
      if (options.autoSetupPrisma && options.runMigration) {
        await migrateAndFormatSchema();
        return;
      }
      const promptResult = await executeRequiredPrompts({
        promptForMigrate: !skipAllPrompts,
        promptForPrismaStudio: false
      });
      if (promptResult?.promptForPrismaMigrate && options.runMigration) {
        await migrateAndFormatSchema();
      }
    };
    const prismaInitWorkflow = async () => {
      await initPrisma({
        directory: LAYER_PATH,
        rootDir: PROJECT_PATH,
        provider: "sqlite"
      });
      await writeToSchema(`${LAYER_PATH}/prisma/schema.prisma`);
    };
    const prismaStudioWorkflow = async () => {
      if (!options.installStudio || npmLifecycleEvent !== "dev") {
        log(PREDEFINED_LOG_MESSAGES.skipInstallingPrismaStudio);
        return;
      }
      const installAndStartPrismaStudio = async () => {
        await installStudio(PROJECT_PATH, PRISMA_SCHEMA_CMD);
        nuxt.hooks.hook("devtools:customTabs", (tab) => {
          tab.push({
            name: "nuxt-prisma",
            title: "Prisma Studio",
            icon: "simple-icons:prisma",
            category: "server",
            view: {
              type: "iframe",
              src: "http://localhost:5555/",
              persistent: true
            }
          });
        });
      };
      await installAndStartPrismaStudio();
    };
    if (!prismaSchemaExists) {
      await prismaInitWorkflow();
    }
    await prismaMigrateWorkflow();
    await writeClientInLib(LAYER_PATH);
    if (options.generateClient) {
      await installPrismaClient(PROJECT_PATH, options.installClient);
      await generatePrismaClient(
        PROJECT_PATH,
        PRISMA_SCHEMA_CMD,
        options.log?.includes("error")
      );
    }
    await prismaStudioWorkflow();
    prepareModule();
  }
});

export { module as default };
